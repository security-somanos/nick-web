!function(){"use strict";let e=null,t=0,n=new Map,i=null,o=!1,r=null,a=null;const s={vertex:"\n      precision highp float;\n      uniform vec2 resolution;\n      uniform float textureAspect;\n      uniform bool aspectCorrectionEnabled;\n      varying vec2 vUv;\n      \n      void main() {\n        vec2 newUv = uv;\n        if (aspectCorrectionEnabled && resolution.y > 0.0 && textureAspect > 0.0) {\n            float containerAspect = resolution.x / resolution.y;\n            if (containerAspect < textureAspect) {\n                newUv.x = (uv.x - 0.5) * (containerAspect / textureAspect) + 0.5;\n            } else {\n                newUv.y = (uv.y - 0.5) * (textureAspect / containerAspect) + 0.5;\n            }\n        }\n        vUv = newUv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    ",base:"\n      precision mediump float;\n      uniform sampler2D u_texture;\n      varying vec2 vUv;\n      \n      void main() {\n        gl_FragColor = texture2D(u_texture, vUv);\n      }\n    ",pixelation:"\n      precision mediump float;\n      uniform sampler2D u_texture;\n      uniform highp vec2 resolution;\n      uniform float pixelSize;\n      uniform float intensity;\n      uniform float time;\n      \n      uniform int pixelShape;\n      uniform int bitDepth;\n      uniform int dithering;\n      uniform int pixelDirection;\n      uniform bool interactionEnabled;\n      uniform bool pixelationEnabled;\n      uniform int isText;\n      \n      uniform bool pixelSizeInteractive;\n      \n      uniform int interactionShape;\n      uniform sampler2D interactionTexture;\n      uniform sampler2D interactionGradientTexture;\n      uniform bool hasCustomInteractionTexture;\n      \n      uniform vec2 mousePx;\n      uniform float radiusPx;\n      uniform float aspect;\n      uniform float pixelRatio;\n      uniform float interactionTextureAspect;\n      uniform float effectScale;\n      \n      varying vec2 vUv;\n      \n      float random(vec2 st) {\n        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n      }\n      \n      float getInteractionEffect(vec2 fragCoord, vec2 mousePositionPx, float radius) {\n        vec2 logicalFragCoord = fragCoord / pixelRatio;\n        vec2 offset = logicalFragCoord - mousePositionPx;\n        float dist = length(offset);\n        \n        float scaledRadius = radius * effectScale;\n        if (scaledRadius <= 0.0) return 0.0;\n\n        if (interactionShape == 1) {\n          float maxDist = max(abs(offset.x), abs(offset.y));\n          return 1.0 - smoothstep(0.0, scaledRadius, maxDist);\n        } else if (interactionShape == 2) {\n          float diamondDist = abs(offset.x) + abs(offset.y);\n          return 1.0 - smoothstep(0.0, scaledRadius, diamondDist);\n        } else if (interactionShape == 3) {\n          float cos45 = 0.707;\n          float sin45 = 0.707;\n          vec2 rotated = vec2(\n            offset.x * cos45 - offset.y * sin45,\n            offset.x * sin45 + offset.y * cos45\n          );\n          float crossRadius = scaledRadius * 0.15;\n          float crossFalloff = scaledRadius;\n          float horizontal = smoothstep(crossRadius, 0.0, abs(rotated.y));\n          float vertical = smoothstep(crossRadius, 0.0, abs(rotated.x));\n          float crossDistance = max(abs(rotated.x), abs(rotated.y));\n          float falloff = smoothstep(crossFalloff, crossFalloff * 0.8, crossDistance);\n          return max(horizontal, vertical) * falloff;\n        } else if (interactionShape == 4) {\n          float plusRadius = scaledRadius * 0.15;\n          float plusFalloff = scaledRadius;\n          float horizontal = smoothstep(plusRadius, 0.0, abs(offset.y));\n          float vertical = smoothstep(plusRadius, 0.0, abs(offset.x));\n          float plusDistance = max(abs(offset.x), abs(offset.y));\n          float falloff = smoothstep(plusFalloff, plusFalloff * 0.8, plusDistance);\n          return max(horizontal, vertical) * falloff;\n        } else if (interactionShape == 5) {\n          if (hasCustomInteractionTexture) {\n            float paddingCompensation = 1.0 / 0.7;\n            vec2 scale = vec2(scaledRadius * 2.0 * paddingCompensation);\n            vec2 textureUV = offset / scale + 0.5;\n            \n            float gradient = 0.0;\n            if (textureUV.x >= 0.0 && textureUV.x <= 1.0 && textureUV.y >= 0.0 && textureUV.y <= 1.0) {\n              gradient = texture2D(interactionGradientTexture, textureUV).r;\n            }\n            \n            return gradient;\n          }\n          return 0.0;\n        } else {\n          return 1.0 - smoothstep(0.0, scaledRadius, dist);\n        }\n      }\n      \n      vec3 applyBitDepth(vec3 color) {\n        if (bitDepth == 1) {\n          float gray = dot(color, vec3(0.299, 0.587, 0.114));\n          return vec3(step(0.5, gray));\n        } else if (bitDepth == 2) {\n          return floor(color * 15.0) / 15.0;\n        } else if (bitDepth == 3) {\n          return floor(color * 255.0) / 255.0;\n        }\n        return color;\n      }\n      \n      vec3 applyDithering(vec3 color, vec2 screenPos) {\n        if (dithering == 1) {\n          vec3 quantized = floor(color * 8.0) / 8.0;\n          vec3 error = color - quantized;\n          float threshold = random(screenPos) * 0.5;\n          return quantized + step(threshold, length(error)) * (error * 0.5);\n        } else if (dithering == 2) {\n          mat4 bayerMatrix = mat4(\n            0.0, 8.0, 2.0, 10.0,\n            12.0, 4.0, 14.0, 6.0,\n            3.0, 11.0, 1.0, 9.0,\n            15.0, 7.0, 13.0, 5.0\n          );\n          \n          int x = int(mod(screenPos.x, 4.0));\n          int y = int(mod(screenPos.y, 4.0));\n          float threshold = bayerMatrix[y][x] / 16.0;\n          \n          return floor(color + threshold) / 16.0 * 16.0;\n        }\n        return color;\n      }\n      \n      float getPixelShapeMask(vec2 pixelUV) {\n        vec2 center = vec2(0.5);\n        vec2 offset = pixelUV - center;\n        \n        if (pixelShape == 1) {\n          return 1.0 - smoothstep(0.3, 0.5, length(offset));\n        } else if (pixelShape == 2) {\n          return 1.0 - smoothstep(0.3, 0.5, abs(offset.x) + abs(offset.y));\n        } else if (pixelShape == 3) {\n          float cos45 = 0.707;\n          float sin45 = 0.707;\n          vec2 rotated = vec2(\n            offset.x * cos45 - offset.y * sin45,\n            offset.x * sin45 + offset.y * cos45\n          );\n          float horizontal = 1.0 - smoothstep(0.05, 0.15, abs(rotated.y));\n          float vertical = 1.0 - smoothstep(0.05, 0.15, abs(rotated.x));\n          return max(horizontal, vertical);\n        } else if (pixelShape == 4) {\n          float horizontal = 1.0 - smoothstep(0.05, 0.15, abs(offset.y));\n          float vertical = 1.0 - smoothstep(0.05, 0.15, abs(offset.x));\n          return max(horizontal, vertical);\n        }\n        return 1.0;\n      }\n      \n      void main() {\n        vec2 uv = vUv;\n        \n        vec4 originalSample = texture2D(u_texture, vUv);\n        if (!pixelationEnabled) {\n          gl_FragColor = originalSample;\n          return;\n        }\n        \n        float effectivePixelSize = pixelSize;\n        \n        if (interactionEnabled) {\n          float mouseEffect = getInteractionEffect(gl_FragCoord.xy, mousePx, radiusPx);\n          float interactionMultiplier = 1.0 + (mouseEffect * intensity);\n          \n          if (pixelSizeInteractive) {\n            effectivePixelSize = max(1.0, pixelSize * (1.0 - mouseEffect * intensity * 0.9));\n          }\n        }\n        \n        vec2 referenceRes = vec2(1920.0, 1080.0);\n        float scaleFactor = min(resolution.x / referenceRes.x, resolution.y / referenceRes.y);\n        float normalizedPixelSize = effectivePixelSize * scaleFactor;\n        \n        vec2 pixelCount;\n        if (pixelDirection == 1) {\n          pixelCount = vec2(resolution.x / normalizedPixelSize, resolution.y / (normalizedPixelSize * 0.3));\n        } else if (pixelDirection == 2) {\n          pixelCount = vec2(resolution.x / (normalizedPixelSize * 0.3), resolution.y / normalizedPixelSize);\n        } else if (pixelDirection == 3) {\n          float diagSize = normalizedPixelSize * 0.707;\n          pixelCount = resolution / diagSize;\n          vec2 center = vec2(0.5);\n          vec2 rotated = uv - center;\n          rotated = vec2(rotated.x * 0.707 - rotated.y * 0.707, rotated.x * 0.707 + rotated.y * 0.707);\n          uv = rotated + center;\n        } else {\n          pixelCount = resolution / normalizedPixelSize;\n        }\n        \n        vec2 uv_for_shaping = uv;\n        vec2 pixelated_uv = floor(uv_for_shaping * pixelCount) / pixelCount;\n        \n        vec4 pixelatedSample = texture2D(u_texture, pixelated_uv);\n        vec3 color = pixelatedSample.rgb;\n        float alpha = pixelatedSample.a;\n        \n        if (pixelShape != 0 && alpha > 0.0) {\n          vec2 pixelUV = fract(uv_for_shaping * pixelCount);\n          float shapeMask = getPixelShapeMask(pixelUV);\n          \n          if (isText == 1) {\n            alpha *= shapeMask;\n          } else {\n            vec3 originalColor = texture2D(u_texture, vUv).rgb;\n            color = mix(originalColor, pixelatedSample.rgb, shapeMask);\n          }\n        }\n        \n        color = applyBitDepth(color);\n        color = applyDithering(color, gl_FragCoord.xy);\n        \n        gl_FragColor = vec4(color, alpha);\n      }\n    ",crt:"\n      precision mediump float;\n      uniform sampler2D u_texture;\n      uniform highp vec2 resolution;\n      uniform float time;\n      uniform float scanlineIntensity;\n      uniform float scanlineThickness;\n      uniform float scanlineCount;\n      uniform float phosphorGlow;\n      uniform float curvature;\n      uniform float chromaticAberration;\n      uniform float brightness;\n      uniform bool flicker;\n      uniform float flickerIntensity;\n      uniform bool lineMovement;\n      uniform float lineSpeed;\n      uniform int lineDirection;\n      uniform float intensity;\n      uniform bool interactionEnabled;\n      uniform bool crtEnabled;\n      \n      uniform bool chromaticAberrationInteractive;\n      uniform bool scanlinesInteractive;\n      uniform bool phosphorGlowInteractive;\n      uniform bool curvatureInteractive;\n      \n      uniform int interactionShape;\n      uniform sampler2D interactionTexture;\n      uniform sampler2D interactionGradientTexture;\n      uniform bool hasCustomInteractionTexture;\n      \n      uniform vec2 mousePx;\n      uniform float radiusPx;\n      uniform float aspect;\n      uniform float pixelRatio;\n      uniform float interactionTextureAspect;\n      uniform float effectScale;\n      \n      uniform bool pixelationEnabled;\n      uniform float pixelSize;\n      \n      varying vec2 vUv;\n      \n      float random(vec2 st) {\n        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n      }\n      \n      float getInteractionEffect(vec2 fragCoord, vec2 mousePositionPx, float radius) {\n        vec2 logicalFragCoord = fragCoord / pixelRatio;\n        vec2 offset = logicalFragCoord - mousePositionPx;\n        \n        float scaledRadius = radius * effectScale;\n        if (scaledRadius <= 0.0) return 0.0;\n        \n        if (interactionShape == 1) {\n          float maxDist = max(abs(offset.x), abs(offset.y));\n          return smoothstep(scaledRadius, 0.0, maxDist);\n        } else if (interactionShape == 2) {\n          float diamondDist = abs(offset.x) + abs(offset.y);\n          return smoothstep(scaledRadius, 0.0, diamondDist);\n        } else if (interactionShape == 3) {\n          float cos45 = 0.707;\n          float sin45 = 0.707;\n          vec2 rotated = vec2(\n            offset.x * cos45 - offset.y * sin45,\n            offset.x * sin45 + offset.y * cos45\n          );\n          float crossRadius = scaledRadius * 0.15;\n          float crossFalloff = scaledRadius;\n          float horizontal = smoothstep(crossRadius, 0.0, abs(rotated.y));\n          float vertical = smoothstep(crossRadius, 0.0, abs(rotated.x));\n          float crossDistance = max(abs(rotated.x), abs(rotated.y));\n          float falloff = smoothstep(crossFalloff, crossFalloff * 0.8, crossDistance);\n          return max(horizontal, vertical) * falloff;\n        } else if (interactionShape == 4) {\n          float plusRadius = scaledRadius * 0.15;\n          float plusFalloff = scaledRadius;\n          float horizontal = smoothstep(plusRadius, 0.0, abs(offset.y));\n          float vertical = smoothstep(plusRadius, 0.0, abs(offset.x));\n          float plusDistance = max(abs(offset.x), abs(offset.y));\n          float falloff = smoothstep(plusFalloff, plusFalloff * 0.8, plusDistance);\n          return max(horizontal, vertical) * falloff;\n        } else if (interactionShape == 5) {\n          if (hasCustomInteractionTexture) {\n            float paddingCompensation = 1.0 / 0.7;\n            vec2 scale = vec2(scaledRadius * 2.0 * paddingCompensation);\n            vec2 textureUV = offset / scale + 0.5;\n            \n            float gradient = 0.0;\n            if (textureUV.x >= 0.0 && textureUV.x <= 1.0 && textureUV.y >= 0.0 && textureUV.y <= 1.0) {\n              gradient = texture2D(interactionGradientTexture, textureUV).r;\n            }\n            \n            return gradient;\n          }\n          float dist = length(offset);\n          return smoothstep(scaledRadius, 0.0, dist);\n        } else {\n          float dist = length(offset);\n          return smoothstep(scaledRadius, 0.0, dist);\n        }\n      }\n      \n      vec2 curveRemapUV(vec2 uv) {\n        uv = uv * 2.0 - 1.0;\n        vec2 offset = abs(uv.yx) * curvature / 20.0;\n        uv = uv + uv * offset * offset;\n        uv = uv * 0.5 + 0.5;\n        return uv;\n      }\n      \n      void main() {\n        vec2 uv = vUv;\n        \n        vec4 originalSample = texture2D(u_texture, vUv);\n        if (!crtEnabled) {\n          gl_FragColor = originalSample;\n          return;\n        }\n        \n        float mouseEffect = 0.0;\n        float interactionMultiplier = 1.0;\n        if (interactionEnabled) {\n          mouseEffect = getInteractionEffect(gl_FragCoord.xy, mousePx, radiusPx);\n          interactionMultiplier = 1.0 + (mouseEffect * intensity);\n        }\n        \n        float effectiveCurvature = curvature;\n        if (curvatureInteractive) {\n          effectiveCurvature = curvature * (1.0 + mouseEffect * intensity);\n          effectiveCurvature = clamp(effectiveCurvature, 0.0, 25.0);\n        }\n        \n        vec2 curvedUV = uv;\n        if (effectiveCurvature > 0.0) {\n          curvedUV = uv * 2.0 - 1.0;\n          vec2 offset = abs(curvedUV.yx) * effectiveCurvature / 20.0;\n          curvedUV = curvedUV + curvedUV * offset * offset;\n          curvedUV = curvedUV * 0.5 + 0.5;\n        }\n        \n        float effectiveAberration = chromaticAberration;\n        if (chromaticAberrationInteractive) {\n          effectiveAberration *= interactionMultiplier;\n        }\n        vec2 aberrationOffset = (curvedUV - 0.5) * effectiveAberration;\n        \n        float r = texture2D(u_texture, curvedUV - aberrationOffset).r;\n        float g = texture2D(u_texture, curvedUV).g;\n        float b = texture2D(u_texture, curvedUV + aberrationOffset).b;\n        \n        vec3 color = vec3(r, g, b);\n        \n        float effectiveScanlineCount = scanlineCount > 0.0 ? scanlineCount : resolution.y * 0.5;\n        \n        vec2 animatedUV = curvedUV;\n        if (lineMovement) {\n          float movement = time * lineSpeed;\n          if (lineDirection == 0) {\n            animatedUV.y += movement;\n          } else if (lineDirection == 1) {\n            animatedUV.y -= movement;\n          } else if (lineDirection == 2) {\n            animatedUV.x += movement;\n          } else if (lineDirection == 3) {\n            animatedUV.x -= movement;\n          }\n        }\n        \n        float scanlinePos;\n        if (lineDirection == 2 || lineDirection == 3) {\n          scanlinePos = animatedUV.x * effectiveScanlineCount;\n        } else {\n          scanlinePos = animatedUV.y * effectiveScanlineCount;\n        }\n        \n        float scanlinePattern = sin(scanlinePos * 3.14159 * 2.0);\n        \n        float thicknessFactor = mix(0.05, 0.95, scanlineThickness);\n        float scanlineMask = smoothstep(-thicknessFactor, thicknessFactor, scanlinePattern);\n        \n        float effectiveScanlineIntensity = scanlineIntensity;\n        if (scanlinesInteractive) {\n          effectiveScanlineIntensity *= interactionMultiplier;\n        }\n        float minIntensity = mix(0.8, 0.1, effectiveScanlineIntensity);\n        float scanlineEffect = mix(minIntensity, 1.0, scanlineMask);\n        color *= scanlineEffect;\n        \n        if (flicker) {\n          float flickerAmount = sin(time * 60.0) * 0.5 + 0.5;\n          flickerAmount = mix(1.0, flickerAmount, flickerIntensity);\n          color *= flickerAmount;\n        }\n        \n        float effectivePhosphorGlow = phosphorGlow;\n        if (phosphorGlowInteractive) {\n          effectivePhosphorGlow *= interactionMultiplier;\n        }\n        color += color * effectivePhosphorGlow;\n        \n        color *= brightness;\n        \n        gl_FragColor = vec4(color, texture2D(u_texture, curvedUV).a);\n      }\n    ",glitch:"\n      precision mediump float;\n      uniform sampler2D u_texture;\n      uniform highp vec2 resolution;\n      uniform float time;\n      uniform float intensity;\n      \n      uniform float rgbShift;\n      uniform float digitalNoise;\n      uniform float lineDisplacement;\n      \n      uniform float bitCrushDepth;\n\n      uniform float signalDropoutFreq;\n      uniform float signalDropoutSize;\n      uniform float syncErrorFreq;\n      uniform float syncErrorAmount;\n      uniform float interferenceSpeed;\n      uniform float interferenceIntensity;\n      uniform float frameGhostAmount;\n      uniform float stutterFreq;\n      uniform float datamoshStrength;\n      \n      uniform bool interactionEnabled;\n      uniform bool rgbShiftInteractive;\n      uniform bool digitalNoiseInteractive;\n      uniform bool lineDisplacementInteractive;\n      uniform bool bitCrushInteractive;\n\n      uniform bool signalDropoutInteractive;\n      uniform bool syncErrorsInteractive;\n      uniform bool interferenceLinesInteractive;\n      uniform bool frameGhostingInteractive;\n      uniform bool stutterFreezeInteractive;\n      uniform bool datamoshingInteractive;\n      \n      uniform int interactionShape;\n      uniform sampler2D interactionTexture;\n      uniform sampler2D interactionGradientTexture;\n      uniform bool hasCustomInteractionTexture;\n      \n      uniform vec2 mousePx;\n      uniform float radiusPx;\n      uniform float aspect;\n      uniform float pixelRatio;\n      uniform float interactionTextureAspect;\n      uniform float effectScale;\n      \n      varying vec2 vUv;\n      \n      float random(vec2 st) {\n        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n      }\n      \n      float random3(vec3 st) {\n        return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 37.719))) * 43758.5453123);\n      }\n      \n      float getInteractionEffect(vec2 fragCoord, vec2 mousePositionPx, float radius) {\n        vec2 logicalFragCoord = fragCoord / pixelRatio;\n        vec2 offset = logicalFragCoord - mousePositionPx;\n        \n        float scaledRadius = radius * effectScale;\n        if (scaledRadius <= 0.0) return 0.0;\n        \n        if (interactionShape == 1) {\n          float maxDist = max(abs(offset.x), abs(offset.y));\n          return smoothstep(scaledRadius, 0.0, maxDist);\n        } else if (interactionShape == 2) {\n          float diamondDist = abs(offset.x) + abs(offset.y);\n          return smoothstep(scaledRadius, 0.0, diamondDist);\n        } else if (interactionShape == 3) {\n          float cos45 = 0.707;\n          float sin45 = 0.707;\n          vec2 rotated = vec2(\n            offset.x * cos45 - offset.y * sin45,\n            offset.x * sin45 + offset.y * cos45\n          );\n          float crossRadius = scaledRadius * 0.15;\n          float crossFalloff = scaledRadius;\n          float horizontal = smoothstep(crossRadius, 0.0, abs(rotated.y));\n          float vertical = smoothstep(crossRadius, 0.0, abs(rotated.x));\n          float crossDistance = max(abs(rotated.x), abs(rotated.y));\n          float falloff = smoothstep(crossFalloff, crossFalloff * 0.8, crossDistance);\n          return max(horizontal, vertical) * falloff;\n        } else if (interactionShape == 4) {\n          float plusRadius = scaledRadius * 0.15;\n          float plusFalloff = scaledRadius;\n          float horizontal = smoothstep(plusRadius, 0.0, abs(offset.y));\n          float vertical = smoothstep(plusRadius, 0.0, abs(offset.x));\n          float plusDistance = max(abs(offset.x), abs(offset.y));\n          float falloff = smoothstep(plusFalloff, plusFalloff * 0.8, plusDistance);\n          return max(horizontal, vertical) * falloff;\n        } else if (interactionShape == 5) {\n          if (hasCustomInteractionTexture) {\n            float paddingCompensation = 1.0 / 0.7;\n            vec2 scale = vec2(scaledRadius * 2.0 * paddingCompensation);\n            vec2 textureUV = offset / scale + 0.5;\n            \n            float gradient = 0.0;\n            if (textureUV.x >= 0.0 && textureUV.x <= 1.0 && textureUV.y >= 0.0 && textureUV.y <= 1.0) {\n              gradient = texture2D(interactionGradientTexture, textureUV).r;\n            }\n            \n            return gradient;\n          }\n          return 0.0;\n        } else {\n          float dist = length(offset);\n          return smoothstep(scaledRadius, 0.0, dist);\n        }\n      }\n      \n      void main() {\n        vec2 uv = vUv;\n        vec3 color = texture2D(u_texture, uv).rgb;\n        \n        float mouseEffect = 0.0;\n        if (interactionEnabled) {\n          mouseEffect = getInteractionEffect(gl_FragCoord.xy, mousePx, radiusPx);\n        }\n        float interactionMultiplier = 1.0 + (mouseEffect * intensity);\n        \n        if (signalDropoutFreq > 0.0) {\n          float effectiveDropout = signalDropoutFreq;\n          if (signalDropoutInteractive) effectiveDropout *= interactionMultiplier;\n          \n          vec2 dropoutSize = vec2(signalDropoutSize * 5.0);\n          vec2 dropoutUV = floor(uv / dropoutSize) * dropoutSize;\n          float dropoutNoise = random3(vec3(dropoutUV, floor(time * 6.0)));\n          \n          if (dropoutNoise < effectiveDropout * 3.0) {\n            if (dropoutNoise < effectiveDropout * 1.0) {\n              color = vec3(0.0);\n            } else if (dropoutNoise < effectiveDropout * 2.0) {\n              color = vec3(1.0);\n            } else {\n              color = vec3(1.0, 0.0, 0.0);\n            }\n          }\n        }\n        \n        if (syncErrorFreq > 0.0) {\n          float effectiveSync = syncErrorAmount;\n          if (syncErrorsInteractive) effectiveSync *= interactionMultiplier;\n          \n          float lineNoise = random(vec2(floor(uv.y * 100.0), floor(time * 8.0)));\n          if (lineNoise < syncErrorFreq * 10.0) {\n            float displacement = (random(vec2(uv.y, time)) - 0.5) * effectiveSync * 20.0;\n            vec2 syncUV = vec2(uv.x + displacement, uv.y);\n            color = sampleWithEffects(syncUV, mouseEffect, interactionMultiplier).rgb;\n          }\n        }\n        \n        if (interferenceIntensity > 0.0) {\n          float effectiveInterference = interferenceIntensity;\n          if (interferenceLinesInteractive) effectiveInterference *= interactionMultiplier;\n          \n          float interference = sin((uv.y + time * interferenceSpeed * 2.0) * 100.0);\n          color += vec3(interference * effectiveInterference);\n        }\n        \n        if (frameGhostAmount > 0.0) {\n          float effectiveGhost = frameGhostAmount;\n          if (frameGhostingInteractive) effectiveGhost *= interactionMultiplier;\n          \n          vec2 ghost1 = uv + vec2(sin(time * 0.5) * 0.02, cos(time * 0.3) * 0.02);\n          vec2 ghost2 = uv + vec2(sin(time * 0.7) * 0.03, cos(time * 0.5) * 0.015);\n          vec2 ghost3 = uv + vec2(sin(time * 0.9) * 0.025, cos(time * 0.7) * 0.02);\n          \n          vec3 ghostColor1 = texture2D(u_texture, ghost1).rgb;\n          vec3 ghostColor2 = texture2D(u_texture, ghost2).rgb;\n          vec3 ghostColor3 = texture2D(u_texture, ghost3).rgb;\n          \n          vec3 ghostMix = (ghostColor1 + ghostColor2 + ghostColor3) / 3.0;\n          color = mix(color, ghostMix, effectiveGhost);\n        }\n        \n        if (stutterFreq > 0.0) {\n          float stutterNoise = random(vec2(floor(time * 10.0), floor(uv.y * 50.0)));\n          if (stutterNoise < stutterFreq * 5.0) {\n            color = color;\n          }\n        }\n        \n        if (datamoshStrength > 0.0) {\n          float effectiveDatamosh = datamoshStrength;\n          if (datamoshingInteractive && mouseEffect > 0.0) {\n            effectiveDatamosh *= interactionMultiplier;\n            \n            vec2 mouseUV = mousePx / resolution;\n            vec2 distortion = (uv - mouseUV) * mouseEffect * effectiveDatamosh * 0.3;\n            vec2 datamoshUV = uv + vec2(\n              sin(distortion.x * 20.0 + time) * 0.02,\n              cos(distortion.y * 15.0 + time) * 0.025\n            ) * mouseEffect;\n            color = sampleWithEffects(datamoshUV, mouseEffect, interactionMultiplier).rgb;\n          } else if (!datamoshingInteractive) {\n            vec2 globalDistortion = vec2(\n              sin(uv.x * 10.0 + time * 2.0) * effectiveDatamosh * 0.01,\n              cos(uv.y * 8.0 + time * 1.5) * effectiveDatamosh * 0.012\n            );\n            color = sampleWithEffects(uv + globalDistortion, mouseEffect, interactionMultiplier).rgb;\n          }\n        }\n        \n        float effectiveShift = rgbShift;\n        if (rgbShiftInteractive) effectiveShift *= interactionMultiplier;\n        \n        if (effectiveShift > 0.0) {\n          vec3 shiftedColor = color;\n          float shiftAmount = effectiveShift * sin(time * 10.0 + uv.y * 50.0) * 50.0;\n          shiftedColor.r = mix(color.r, color.g, abs(shiftAmount));\n          shiftedColor.b = mix(color.b, color.g, abs(shiftAmount));\n          color = mix(color, shiftedColor, clamp(effectiveShift * 20.0, 0.0, 1.0));\n        }\n        \n        if (bitCrushDepth > 0.0) {\n          float effectiveDepth = bitCrushDepth;\n          if (bitCrushInteractive) effectiveDepth *= interactionMultiplier;\n          \n          float levels = max(2.0, 32.0 - effectiveDepth * 4.0);\n          color = floor(color * levels) / levels;\n        }\n        \n        if (lineDisplacement > 0.0) {\n          float effectiveDisplacement = lineDisplacement;\n          if (lineDisplacementInteractive) effectiveDisplacement *= interactionMultiplier;\n          \n          float lineNoise = random(vec2(floor(uv.y * 100.0), floor(time * 8.0)));\n          if (lineNoise > 0.95) {\n            float displacement = (random(vec2(uv.y, time)) - 0.5) * effectiveDisplacement;\n            float distFromCenter = abs(uv.x - 0.5) * 2.0;\n            float triangularStrength = 0.2 + distFromCenter * 0.8;\n            \n            vec3 distortedColor = color;\n            distortedColor.r = mix(color.r, color.g, abs(displacement * triangularStrength * 50.0));\n            distortedColor.b = mix(color.b, color.r, abs(displacement * triangularStrength * 50.0));\n            color = mix(color, distortedColor, clamp(effectiveDisplacement * 10.0, 0.0, 1.0));\n          }\n        }\n        \n        if (digitalNoise > 0.0) {\n          float effectiveNoise = digitalNoise;\n          if (digitalNoiseInteractive) effectiveNoise *= interactionMultiplier;\n          \n          float noise = random(uv + time);\n          if (noise > (1.0 - effectiveNoise * 0.1)) {\n            color = mix(color, vec3(noise), effectiveNoise * 0.8);\n          }\n        }\n        \n\n        \n        gl_FragColor = vec4(color, 1.0);\n      }\n    ",combined:"\n      precision mediump float;\n      uniform sampler2D u_texture;\n      uniform highp vec2 resolution;\n      uniform float time;\n      uniform float intensity;\n      \n      uniform bool pixelationEnabled;\n      uniform bool crtEnabled;\n      uniform bool glitchEnabled;\n      \n      // ===== PIXELATION UNIFORMS =====\n      uniform float pixelSize;\n      uniform int pixelShape;\n      uniform int bitDepth;\n      uniform int dithering;\n      uniform int pixelDirection;\n      uniform int isText;\n      uniform bool pixelSizeInteractive;\n      \n      // ===== CRT UNIFORMS =====\n      uniform float scanlineIntensity;\n      uniform float scanlineThickness;\n      uniform float scanlineCount;\n      uniform float phosphorGlow;\n      uniform float curvature;\n      uniform float chromaticAberration;\n      uniform float brightness;\n      uniform bool flicker;\n      uniform float flickerIntensity;\n      uniform bool lineMovement;\n      uniform float lineSpeed;\n      uniform int lineDirection;\n      uniform bool chromaticAberrationInteractive;\n      uniform bool scanlinesInteractive;\n      uniform bool phosphorGlowInteractive;\n      uniform bool curvatureInteractive;\n      \n      // ===== GLITCH UNIFORMS =====\n      uniform float rgbShift;\n      uniform float digitalNoise;\n      uniform float lineDisplacement;\n      uniform float bitCrushDepth;\n      uniform float signalDropoutFreq;\n      uniform float signalDropoutSize;\n      uniform float syncErrorFreq;\n      uniform float syncErrorAmount;\n      uniform float interferenceSpeed;\n      uniform float interferenceIntensity;\n      uniform float frameGhostAmount;\n      uniform float stutterFreq;\n      uniform float datamoshStrength;\n      uniform bool rgbShiftInteractive;\n      uniform bool digitalNoiseInteractive;\n      uniform bool lineDisplacementInteractive;\n      uniform bool bitCrushInteractive;\n      uniform bool signalDropoutInteractive;\n      uniform bool syncErrorsInteractive;\n      uniform bool interferenceLinesInteractive;\n      uniform bool frameGhostingInteractive;\n      uniform bool stutterFreezeInteractive;\n      uniform bool datamoshingInteractive;\n      \n      // ===== SHARED INTERACTION UNIFORMS =====\n      uniform bool interactionEnabled;\n      uniform int interactionShape;\n      uniform sampler2D interactionTexture;\n      uniform sampler2D interactionGradientTexture;\n      uniform bool hasCustomInteractionTexture;\n      uniform vec2 mousePx;\n      uniform float radiusPx;\n      uniform float aspect;\n      uniform float pixelRatio;\n      uniform float interactionTextureAspect;\n      uniform float effectScale;\n      \n      varying vec2 vUv;\n      \n      // ===== UTILITY FUNCTIONS =====\n      float random(vec2 st) {\n        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n      }\n      \n      float random3(vec3 st) {\n        return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 37.719))) * 43758.5453123);\n      }\n      \n      float getInteractionEffect(vec2 fragCoord, vec2 mousePositionPx, float radius) {\n        vec2 logicalFragCoord = fragCoord / pixelRatio;\n        vec2 offset = logicalFragCoord - mousePositionPx;\n        float dist = length(offset);\n        \n        float scaledRadius = radius * effectScale;\n        if (scaledRadius <= 0.0) return 0.0;\n\n        if (interactionShape == 1) {\n          float maxDist = max(abs(offset.x), abs(offset.y));\n          return 1.0 - smoothstep(0.0, scaledRadius, maxDist);\n        } else if (interactionShape == 2) {\n          float diamondDist = abs(offset.x) + abs(offset.y);\n          return 1.0 - smoothstep(0.0, scaledRadius, diamondDist);\n        } else if (interactionShape == 3) {\n          float cos45 = 0.707;\n          float sin45 = 0.707;\n          vec2 rotated = vec2(\n            offset.x * cos45 - offset.y * sin45,\n            offset.x * sin45 + offset.y * cos45\n          );\n          float crossRadius = scaledRadius * 0.15;\n          float crossFalloff = scaledRadius;\n          float horizontal = smoothstep(crossRadius, 0.0, abs(rotated.y));\n          float vertical = smoothstep(crossRadius, 0.0, abs(rotated.x));\n          float crossDistance = max(abs(rotated.x), abs(rotated.y));\n          float falloff = smoothstep(crossFalloff, crossFalloff * 0.8, crossDistance);\n          return max(horizontal, vertical) * falloff;\n        } else if (interactionShape == 4) {\n          float plusRadius = scaledRadius * 0.15;\n          float plusFalloff = scaledRadius;\n          float horizontal = smoothstep(plusRadius, 0.0, abs(offset.y));\n          float vertical = smoothstep(plusRadius, 0.0, abs(offset.x));\n          float plusDistance = max(abs(offset.x), abs(offset.y));\n          float falloff = smoothstep(plusFalloff, plusFalloff * 0.8, plusDistance);\n          return max(horizontal, vertical) * falloff;\n        } else if (interactionShape == 5) {\n          if (hasCustomInteractionTexture) {\n            float paddingCompensation = 1.0 / 0.7;\n            vec2 scale = vec2(scaledRadius * 2.0 * paddingCompensation);\n            vec2 textureUV = offset / scale + 0.5;\n            \n            float gradient = 0.0;\n            if (textureUV.x >= 0.0 && textureUV.x <= 1.0 && textureUV.y >= 0.0 && textureUV.y <= 1.0) {\n              gradient = texture2D(interactionGradientTexture, textureUV).r;\n            }\n            \n            return gradient;\n          }\n          return 0.0;\n        } else {\n          return 1.0 - smoothstep(0.0, scaledRadius, dist);\n        }\n      }\n      \n      // ===== PIXELATION EFFECT FUNCTIONS =====\n      vec3 applyBitDepth(vec3 color) {\n        if (bitDepth == 1) {\n          float gray = dot(color, vec3(0.299, 0.587, 0.114));\n          return vec3(step(0.5, gray));\n        } else if (bitDepth == 2) {\n          return floor(color * 15.0) / 15.0;\n        } else if (bitDepth == 3) {\n          return floor(color * 255.0) / 255.0;\n        }\n        return color;\n      }\n      \n      vec3 applyDithering(vec3 color, vec2 screenPos) {\n        if (dithering == 1) {\n          vec3 quantized = floor(color * 8.0) / 8.0;\n          vec3 error = color - quantized;\n          float threshold = random(screenPos) * 0.5;\n          return quantized + step(threshold, length(error)) * (error * 0.5);\n        } else if (dithering == 2) {\n          mat4 bayerMatrix = mat4(\n            0.0, 8.0, 2.0, 10.0,\n            12.0, 4.0, 14.0, 6.0,\n            3.0, 11.0, 1.0, 9.0,\n            15.0, 7.0, 13.0, 5.0\n          );\n          \n          int x = int(mod(screenPos.x, 4.0));\n          int y = int(mod(screenPos.y, 4.0));\n          float threshold = bayerMatrix[y][x] / 16.0;\n          \n          return floor(color + threshold) / 16.0 * 16.0;\n        }\n        return color;\n      }\n      \n      float getPixelShapeMask(vec2 pixelUV) {\n        vec2 center = vec2(0.5);\n        vec2 offset = pixelUV - center;\n        \n        if (pixelShape == 1) {\n          return 1.0 - smoothstep(0.3, 0.5, length(offset));\n        } else if (pixelShape == 2) {\n          return 1.0 - smoothstep(0.3, 0.5, abs(offset.x) + abs(offset.y));\n        } else if (pixelShape == 3) {\n          float cos45 = 0.707;\n          float sin45 = 0.707;\n          vec2 rotated = vec2(\n            offset.x * cos45 - offset.y * sin45,\n            offset.x * sin45 + offset.y * cos45\n          );\n          float horizontal = 1.0 - smoothstep(0.05, 0.15, abs(rotated.y));\n          float vertical = 1.0 - smoothstep(0.05, 0.15, abs(rotated.x));\n          return max(horizontal, vertical);\n        } else if (pixelShape == 4) {\n          float horizontal = 1.0 - smoothstep(0.05, 0.15, abs(offset.y));\n          float vertical = 1.0 - smoothstep(0.05, 0.15, abs(offset.x));\n          return max(horizontal, vertical);\n        }\n        return 1.0;\n      }\n      \n      vec4 applyPixelationToUV(vec2 uv, float mouseEffect, float interactionMultiplier) {\n        float effectivePixelSize = pixelSize;\n        \n        if (interactionEnabled) {\n          if (pixelSizeInteractive) {\n            effectivePixelSize = max(1.0, pixelSize * (1.0 - mouseEffect * intensity * 0.9));\n          }\n        }\n        \n        vec2 referenceRes = vec2(1920.0, 1080.0);\n        float scaleFactor = min(resolution.x / referenceRes.x, resolution.y / referenceRes.y);\n        float normalizedPixelSize = effectivePixelSize * scaleFactor;\n        \n        vec2 pixelCount;\n        vec2 workingUV = uv;\n        \n        if (pixelDirection == 1) {\n          pixelCount = vec2(resolution.x / normalizedPixelSize, resolution.y / (normalizedPixelSize * 0.3));\n        } else if (pixelDirection == 2) {\n          pixelCount = vec2(resolution.x / (normalizedPixelSize * 0.3), resolution.y / normalizedPixelSize);\n        } else if (pixelDirection == 3) {\n          float diagSize = normalizedPixelSize * 0.707;\n          pixelCount = resolution / diagSize;\n          vec2 center = vec2(0.5);\n          vec2 rotated = workingUV - center;\n          rotated = vec2(rotated.x * 0.707 - rotated.y * 0.707, rotated.x * 0.707 + rotated.y * 0.707);\n          workingUV = rotated + center;\n        } else {\n          pixelCount = resolution / normalizedPixelSize;\n        }\n        \n        vec2 pixelated_uv = floor(workingUV * pixelCount) / pixelCount;\n        vec4 pixelatedSample = texture2D(u_texture, pixelated_uv);\n        vec3 color = pixelatedSample.rgb;\n        float alpha = pixelatedSample.a;\n        \n        vec4 originalSample = texture2D(u_texture, uv);\n        \n        if (pixelShape != 0 && alpha > 0.0) {\n          vec2 pixelUV = fract(workingUV * pixelCount);\n          float shapeMask = getPixelShapeMask(pixelUV);\n          \n          if (isText == 1) {\n            alpha *= shapeMask;\n          } else {\n            vec3 originalColor = originalSample.rgb;\n            color = mix(originalColor, pixelatedSample.rgb, shapeMask);\n          }\n        }\n        \n        color = applyBitDepth(color);\n        color = applyDithering(color, gl_FragCoord.xy);\n        \n        return vec4(color, alpha);\n      }\n      \n      vec3 applyCRTColorEffects(vec3 color, vec2 uv, float mouseEffect, float interactionMultiplier) {\n        if (!crtEnabled) return color;\n        \n        if (chromaticAberration > 0.0) {\n          float effectiveAberration = chromaticAberration;\n          if (chromaticAberrationInteractive) {\n            effectiveAberration *= interactionMultiplier;\n          }\n          \n          vec2 aberrationOffset = (uv - 0.5) * effectiveAberration;\n          vec3 aberratedColor = color;\n          aberratedColor.r *= 1.0 + abs(aberrationOffset.x) * 2.0;\n          aberratedColor.b *= 1.0 + abs(aberrationOffset.x) * 2.0;\n          color = mix(color, aberratedColor, clamp(effectiveAberration * 10.0, 0.0, 0.5));\n        }\n        \n        float effectiveScanlineCount = scanlineCount > 0.0 ? scanlineCount : resolution.y * 0.5;\n        vec2 animatedUV = uv;\n        if (lineMovement) {\n          float movement = time * lineSpeed;\n          if (lineDirection == 0) animatedUV.y += movement;\n          else if (lineDirection == 1) animatedUV.y -= movement;\n          else if (lineDirection == 2) animatedUV.x += movement;\n          else if (lineDirection == 3) animatedUV.x -= movement;\n        }\n        \n        float scanlinePos = (lineDirection == 2 || lineDirection == 3) \n          ? animatedUV.x * effectiveScanlineCount \n          : animatedUV.y * effectiveScanlineCount;\n        \n        float scanlinePattern = sin(scanlinePos * 3.14159 * 2.0);\n        float thicknessFactor = mix(0.05, 0.95, scanlineThickness);\n        float scanlineMask = smoothstep(-thicknessFactor, thicknessFactor, scanlinePattern);\n        \n        float effectiveScanlineIntensity = scanlineIntensity;\n        if (scanlinesInteractive) {\n          effectiveScanlineIntensity *= interactionMultiplier;\n        }\n        float minIntensity = mix(0.8, 0.1, effectiveScanlineIntensity);\n        float scanlineEffect = mix(minIntensity, 1.0, scanlineMask);\n        color *= scanlineEffect;\n        \n        if (flicker) {\n          float flickerAmount = sin(time * 60.0) * 0.5 + 0.5;\n          flickerAmount = mix(1.0, flickerAmount, flickerIntensity);\n          color *= flickerAmount;\n        }\n        \n        float effectivePhosphorGlow = phosphorGlow;\n        if (phosphorGlowInteractive) {\n          effectivePhosphorGlow *= interactionMultiplier;\n        }\n        color += color * effectivePhosphorGlow;\n        \n        color *= brightness;\n        \n        return color;\n      }\n      \n      vec4 sampleWithGeometricEffects(vec2 uv, float mouseEffect, float interactionMultiplier) {\n        vec2 samplingUV = uv;\n        if (crtEnabled && curvature > 0.0) {\n          float effectiveCurvature = curvature;\n          if (curvatureInteractive) {\n            effectiveCurvature = curvature * (1.0 + mouseEffect * intensity);\n            effectiveCurvature = clamp(effectiveCurvature, 0.0, 25.0);\n          }\n          \n          vec2 curvedUV = uv * 2.0 - 1.0;\n          vec2 offset = abs(curvedUV.yx) * effectiveCurvature / 20.0;\n          curvedUV = curvedUV + curvedUV * offset * offset;\n          samplingUV = curvedUV * 0.5 + 0.5;\n        }\n        \n        if (pixelationEnabled) {\n          vec4 pixelatedResult = applyPixelationToUV(samplingUV, mouseEffect, interactionMultiplier);\n          return pixelatedResult;\n        }\n        \n        return texture2D(u_texture, samplingUV);\n      }\n      \n      vec4 sampleWithEffects(vec2 uv, float mouseEffect, float interactionMultiplier) {\n        vec4 sampledColor = sampleWithGeometricEffects(uv, mouseEffect, interactionMultiplier);\n        \n        if (crtEnabled) {\n          sampledColor.rgb = applyCRTColorEffects(sampledColor.rgb, uv, mouseEffect, interactionMultiplier);\n        }\n        \n        return sampledColor;\n      }\n      \n      vec4 applyPixelation(vec2 uv, vec4 inputColor, float mouseEffect, float interactionMultiplier) {\n        float effectivePixelSize = pixelSize;\n        \n        if (interactionEnabled) {\n          if (pixelSizeInteractive) {\n            effectivePixelSize = max(1.0, pixelSize * (1.0 - mouseEffect * intensity * 0.9));\n          }\n        }\n        \n        vec2 referenceRes = vec2(1920.0, 1080.0);\n        float scaleFactor = min(resolution.x / referenceRes.x, resolution.y / referenceRes.y);\n        float normalizedPixelSize = effectivePixelSize * scaleFactor;\n        \n        vec2 pixelCount;\n        vec2 workingUV = uv;\n        \n        if (pixelDirection == 1) {\n          pixelCount = vec2(resolution.x / normalizedPixelSize, resolution.y / (normalizedPixelSize * 0.3));\n        } else if (pixelDirection == 2) {\n          pixelCount = vec2(resolution.x / (normalizedPixelSize * 0.3), resolution.y / normalizedPixelSize);\n        } else if (pixelDirection == 3) {\n          float diagSize = normalizedPixelSize * 0.707;\n          pixelCount = resolution / diagSize;\n          vec2 center = vec2(0.5);\n          vec2 rotated = workingUV - center;\n          rotated = vec2(rotated.x * 0.707 - rotated.y * 0.707, rotated.x * 0.707 + rotated.y * 0.707);\n          workingUV = rotated + center;\n        } else {\n          pixelCount = resolution / normalizedPixelSize;\n        }\n        \n        vec2 pixelated_uv = floor(workingUV * pixelCount) / pixelCount;\n        vec4 pixelatedSample = texture2D(u_texture, pixelated_uv);\n        vec3 color = pixelatedSample.rgb;\n        float alpha = pixelatedSample.a;\n        \n        if (pixelShape != 0 && alpha > 0.0) {\n          vec2 pixelUV = fract(workingUV * pixelCount);\n          float shapeMask = getPixelShapeMask(pixelUV);\n          \n          if (isText == 1) {\n            alpha *= shapeMask;\n          } else {\n            vec3 originalColor = inputColor.rgb;\n            color = mix(originalColor, pixelatedSample.rgb, shapeMask);\n          }\n        }\n        \n        color = applyBitDepth(color);\n        color = applyDithering(color, gl_FragCoord.xy);\n        \n        return vec4(color, alpha);\n      }\n      \n      // ===== CRT EFFECT FUNCTIONS =====\n       vec4 applyCRT(vec2 uv, vec4 inputColor, float mouseEffect, float interactionMultiplier) {\n\n         vec3 color = applyCRTColorEffects(inputColor.rgb, uv, mouseEffect, interactionMultiplier);\n         return vec4(color, inputColor.a);\n      }\n      \n      // ===== GLITCH EFFECT FUNCTIONS =====\n      vec4 applyGlitch(vec2 uv, vec4 inputColor, float mouseEffect, float interactionMultiplier) {\n        vec3 color = inputColor.rgb;\n        \n        if (signalDropoutFreq > 0.0) {\n          float effectiveDropout = signalDropoutFreq;\n                     if (signalDropoutInteractive) effectiveDropout *= interactionMultiplier;\n          \n          vec2 dropoutSize = vec2(signalDropoutSize * 5.0);\n          vec2 dropoutUV = floor(uv / dropoutSize) * dropoutSize;\n          float dropoutNoise = random3(vec3(dropoutUV, floor(time * 6.0)));\n          \n          if (dropoutNoise < effectiveDropout * 3.0) {\n            if (dropoutNoise < effectiveDropout * 1.0) {\n              color = vec3(0.0);\n            } else if (dropoutNoise < effectiveDropout * 2.0) {\n              color = vec3(1.0);\n            } else {\n              color = vec3(1.0, 0.0, 0.0);\n            }\n          }\n        }\n        \n        if (syncErrorFreq > 0.0) {\n          float effectiveSync = syncErrorAmount;\n                     if (syncErrorsInteractive) effectiveSync *= interactionMultiplier;\n          \n          float lineNoise = random(vec2(floor(uv.y * 100.0), floor(time * 8.0)));\n          if (lineNoise < syncErrorFreq * 10.0) {\n            float displacement = (random(vec2(uv.y, time)) - 0.5) * effectiveSync * 20.0;\n            vec2 syncUV = vec2(uv.x + displacement, uv.y);\n            color = sampleWithEffects(syncUV, mouseEffect, interactionMultiplier).rgb;\n          }\n        }\n        \n         if (interferenceIntensity > 0.0) {\n           float effectiveInterference = interferenceIntensity;\n           if (interferenceLinesInteractive) effectiveInterference *= interactionMultiplier;\n           \n           float interference = sin((uv.y + time * interferenceSpeed * 2.0) * 100.0);\n           color += vec3(interference * effectiveInterference);\n         }\n         \n         if (frameGhostAmount > 0.0) {\n           float effectiveGhost = frameGhostAmount;\n           if (frameGhostingInteractive) effectiveGhost *= interactionMultiplier;\n           \n           vec2 ghost1 = uv + vec2(sin(time * 0.5) * 0.02, cos(time * 0.3) * 0.02);\n           vec2 ghost2 = uv + vec2(sin(time * 0.7) * 0.03, cos(time * 0.5) * 0.015);\n           vec2 ghost3 = uv + vec2(sin(time * 0.9) * 0.025, cos(time * 0.7) * 0.02);\n           \n                       vec3 ghostColor1 = sampleWithGeometricEffects(ghost1, mouseEffect, interactionMultiplier).rgb;\n            vec3 ghostColor2 = sampleWithGeometricEffects(ghost2, mouseEffect, interactionMultiplier).rgb;\n            vec3 ghostColor3 = sampleWithGeometricEffects(ghost3, mouseEffect, interactionMultiplier).rgb;\n           \n           vec3 ghostMix = (ghostColor1 + ghostColor2 + ghostColor3) / 3.0;\n           color = mix(color, ghostMix, effectiveGhost);\n         }\n         \n         if (stutterFreq > 0.0) {\n           float stutterNoise = random(vec2(floor(time * 10.0), floor(uv.y * 50.0)));\n           if (stutterNoise < stutterFreq * 5.0) {\n             float frozenTime = floor(time * 3.0) / 3.0;\n             vec2 stutterOffset = vec2(\n               sin(frozenTime * 2.0) * 0.01,\n               cos(frozenTime * 1.5) * 0.008\n             );\n                           color = sampleWithGeometricEffects(uv + stutterOffset, mouseEffect, interactionMultiplier).rgb;\n           }\n         }\n         \n         if (datamoshStrength > 0.0) {\n           float effectiveDatamosh = datamoshStrength;\n           if (datamoshingInteractive && mouseEffect > 0.0) {\n             effectiveDatamosh *= interactionMultiplier;\n             \n             vec2 mouseUV = mousePx / resolution;\n             vec2 distortion = (uv - mouseUV) * mouseEffect * effectiveDatamosh * 0.3;\n             vec2 datamoshUV = uv + vec2(\n               sin(distortion.x * 20.0 + time) * 0.02,\n               cos(distortion.y * 15.0 + time) * 0.025\n             ) * mouseEffect;\n                           color = sampleWithGeometricEffects(datamoshUV, mouseEffect, interactionMultiplier).rgb;\n            } else if (!datamoshingInteractive) {\n              vec2 globalDistortion = vec2(\n                sin(uv.x * 10.0 + time * 2.0) * effectiveDatamosh * 0.01,\n                cos(uv.y * 8.0 + time * 1.5) * effectiveDatamosh * 0.012\n              );\n              color = sampleWithGeometricEffects(uv + globalDistortion, mouseEffect, interactionMultiplier).rgb;\n           }\n         }\n         \n         float effectiveShift = rgbShift;\n         if (rgbShiftInteractive) effectiveShift *= interactionMultiplier;\n         \n         if (effectiveShift > 0.0) {\n           vec2 shiftOffset = vec2(effectiveShift, 0.0) * sin(time * 10.0 + uv.y * 50.0);\n           float r = sampleWithGeometricEffects(uv - shiftOffset, mouseEffect, interactionMultiplier).r;\n           float g = color.g;\n           float b = sampleWithGeometricEffects(uv + shiftOffset, mouseEffect, interactionMultiplier).b;\n           color = vec3(r, g, b);\n         }\n         \n         if (bitCrushDepth > 0.0) {\n           float effectiveDepth = bitCrushDepth;\n           if (bitCrushInteractive) effectiveDepth *= interactionMultiplier;\n           \n           float levels = max(2.0, 32.0 - effectiveDepth * 4.0);\n           color = floor(color * levels) / levels;\n         }\n         \n         if (lineDisplacement > 0.0) {\n           float effectiveDisplacement = lineDisplacement;\n           if (lineDisplacementInteractive) effectiveDisplacement *= interactionMultiplier;\n           \n           float lineNoise = random(vec2(floor(uv.y * 100.0), floor(time * 8.0)));\n           if (lineNoise > 0.95) {\n             float displacement = (random(vec2(uv.y, time)) - 0.5) * effectiveDisplacement;\n             float distFromCenter = abs(uv.x - 0.5) * 2.0;\n             float triangularStrength = 0.2 + distFromCenter * 0.8;\n             vec2 displacedUV = uv + vec2(displacement * triangularStrength * 50.0, 0.0);\n                           color = sampleWithGeometricEffects(displacedUV, mouseEffect, interactionMultiplier).rgb;\n           }\n         }\n         \n         if (digitalNoise > 0.0) {\n           float effectiveNoise = digitalNoise;\n           if (digitalNoiseInteractive) effectiveNoise *= interactionMultiplier;\n           \n           float noise = random(uv + time);\n           if (noise > (1.0 - effectiveNoise * 0.1)) {\n             color = mix(color, vec3(noise), effectiveNoise * 0.8);\n           }\n         }\n         \n         return vec4(color, inputColor.a);\n      }\n      \n      void main() {\n        vec2 uv = vUv;\n        \n        float mouseEffect = 0.0;\n        float interactionMultiplier = 1.0;\n        if (interactionEnabled) {\n          mouseEffect = getInteractionEffect(gl_FragCoord.xy, mousePx, radiusPx);\n          interactionMultiplier = 1.0 + (mouseEffect * intensity);\n        }\n        \n        vec2 baseUV = uv;\n        vec2 curvedUV = uv;\n        if (crtEnabled && curvature > 0.0) {\n          float effectiveCurvature = curvature;\n          if (curvatureInteractive) {\n            effectiveCurvature = curvature * (1.0 + mouseEffect * intensity);\n            effectiveCurvature = clamp(effectiveCurvature, 0.0, 25.0);\n          }\n          \n          curvedUV = uv * 2.0 - 1.0;\n          vec2 offset = abs(curvedUV.yx) * effectiveCurvature / 20.0;\n          curvedUV = curvedUV + curvedUV * offset * offset;\n          curvedUV = curvedUV * 0.5 + 0.5;\n        }\n        \n        vec2 samplingUV = (crtEnabled && curvature > 0.0) ? curvedUV : baseUV;\n        \n        vec4 color = texture2D(u_texture, samplingUV);\n        \n        if (pixelationEnabled) {\n          color = applyPixelation(samplingUV, color, mouseEffect, interactionMultiplier);\n        }\n        \n        if (glitchEnabled) {\n          color = applyGlitch(samplingUV, color, mouseEffect, interactionMultiplier);\n        }\n        \n        if (crtEnabled) {\n          color = applyCRT(samplingUV, color, mouseEffect, interactionMultiplier);\n        }\n        \n        gl_FragColor = color;\n      }\n    "};class l{constructor(){this.glitchSystems=new Map,this.targetElements=new Map,this.renderers=new Map,this.mouse=new THREE.Vector2,this.lastMousePos=new THREE.Vector2,this.mouseVelocity=0,this.lastMoveTime=0,this.currentEffectScale=0,this.targetEffectScale=0,this.onMouseMove=this.onMouseMove.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),document.addEventListener("mousemove",this.onMouseMove),document.addEventListener("touchstart",this.onTouchStart,{passive:!0}),document.addEventListener("touchmove",this.onTouchMove,{passive:!0}),document.addEventListener("touchend",this.onTouchEnd,{passive:!0})}addGlitchSystem(e,t,n){const i=!!t.dataset.modelSrc,o=new THREE.WebGLRenderer({antialias:!1,powerPreference:"high-performance",alpha:!0}),r=Math.min(window.devicePixelRatio,2);o.setPixelRatio(r),o.setClearColor(0,0);const a=new THREE.Scene,s=i?new THREE.PerspectiveCamera(75,1,.1,1e3):new THREE.OrthographicCamera(-1,1,1,-1,.1,1e3);if(i){s.position.z=2,a.background=null;const e=new THREE.AmbientLight(16777215,.7);a.add(e);const t=new THREE.DirectionalLight(16777215,.8);t.position.set(1,1,1),a.add(t)}const l=i?new THREE.Scene:null,c=i?new THREE.OrthographicCamera(-1,1,1,-1,.1,1e3):null,f=new THREE.WebGLRenderTarget(1,1),u=new THREE.WebGLRenderTarget(1,1),d=o.domElement;if(d.setAttribute("data-glitch-target",e),t.parentNode.insertBefore(d,t.nextSibling),this.renderers.set(e,{renderer:o,scene:a,camera:s,postScene:l,postCamera:c,renderTarget1:f,renderTarget2:u,is3D:i}),this.glitchSystems.set(e,{element:t,options:n,inView:!1,observer:null,originalVisibility:t.style.visibility,isMouseOver:!1,currentMouse:new THREE.Vector2,lastMousePos:new THREE.Vector2,targetRotation:new THREE.Vector2,isVideo:"video"===t.tagName.toLowerCase(),is3D:i,model:null,elementTexture:null,glitchMaterial:null,quad:null,time:0,needsRender:!0,lastRenderTime:0,lastContainerAspect:null}),this.targetElements.set(e,t),"video"===t.tagName.toLowerCase()){if(/^((?!chrome|android).)*safari/i.test(navigator.userAgent)){t.hasAttribute("playsinline")||t.setAttribute("playsinline",""),t.hasAttribute("muted")||t.setAttribute("muted","");const e=()=>{t.paused&&t.play().catch(e=>{console.warn("glitchGL: Video play failed:",e)})};document.addEventListener("click",e,{once:!0}),document.addEventListener("touchstart",e,{once:!0}),setTimeout(()=>{t.paused&&t.play().catch(()=>{})},100)}}if("IntersectionObserver"in window){const n=new IntersectionObserver(t=>{const n=this.glitchSystems.get(e);n&&(n.inView=t[0].isIntersecting,n.inView&&this.triggerRender(e))},{root:null,threshold:0,rootMargin:"500px"});n.observe(t),this.glitchSystems.get(e).observer=n}else this.glitchSystems.get(e).inView=!0;this.glitchSystems.get(e).radiusPx=this.getInteractionRadiusPx(this.glitchSystems.get(e).options,t),this.initializeGlitchEffect(e).then(()=>{this.glitchSystems.has(e)&&(t.style.visibility="hidden")})}async initializeGlitchEffect(e){const t=this.glitchSystems.get(e),n=this.renderers.get(e);if(!t||!n)return;if(n.is3D){t.model=await this.loadModel(t.element.dataset.modelSrc,n.scene,t.options);const e=t.element.getBoundingClientRect();t.elementTexture=new THREE.WebGLRenderTarget(e.width,e.height)}else{t.elementTexture=await this.elementToTexture(t.element,t.options);const e=t.element.getBoundingClientRect();t.lastContainerAspect=e.width/e.height}const i=new THREE.PlaneGeometry(2,2),o=n.is3D?t.elementTexture.texture:t.elementTexture;t.glitchMaterial=await this.createCombinedMaterial(t.options,o,t.element,t,n),t.quad=new THREE.Mesh(i,t.glitchMaterial),t.quad.position.z=-1,n.is3D?n.postScene.add(t.quad):n.scene.add(t.quad)}async loadModel(e,t,n){return new Promise((i,o)=>{if("undefined"==typeof THREE||!THREE.GLTFLoader)return console.error("glitchGL: THREE.js and THREE.GLTFLoader are required for model loading."),o("Missing THREE.js or GLTFLoader.");const r=new THREE.GLTFLoader,a=THREE.LoaderUtils.extractUrlBase(e);r.setPath(a);const s=e.substring(a.length);r.load(s,e=>{const o=e.scene,r=(new THREE.Box3).setFromObject(o),a=r.getCenter(new THREE.Vector3),s=r.getSize(new THREE.Vector3),l=Math.max(s.x,s.y,s.z),c=(n.modelScale||1.5)/l;o.scale.set(c,c,c),o.position.sub(a.multiplyScalar(c)),t.add(o),i(o)},void 0,t=>{console.error(`glitchGL: Failed to load 3D model from ${e}`,t),o(`Failed to load model: ${t}`)})})}async createCombinedMaterial(e,t,n,i,o){return this.createEffectMaterial("combined",e,t,n,i,o)}async createEffectMaterial(e,t,n,i,o,r){let a=s.combined;const l=!["IMG","VIDEO","CANVAS","SVG"].includes(i.tagName.toUpperCase()),c=t.interaction||null;let f=null,u=null;if(c&&c.enabled&&"custom"===c.shape&&c.customUrl)try{const e=await this.loadCustomInteractionTexture(c.customUrl);e&&(f=e.texture,u=e.gradientTexture)}catch(e){console.error("glitchGL: Failed to load custom interaction texture, using default.",e),f=null,u=null}let d=c?.shape||"circle",h=1;if(f&&f.image){const e=f.image;e.width&&e.height>0&&(h=e.width/e.height)}let m=1;if(n&&n.image){const e=n.image,t=e.width||e.videoWidth,i=e.height||e.videoHeight;t&&i>0&&(m=t/i)}const p=new THREE.ShaderMaterial({vertexShader:s.vertex,fragmentShader:a,uniforms:{u_texture:{value:n},resolution:{value:new THREE.Vector2(1,1)},time:{value:0},mousePx:{value:new THREE.Vector2(0,0)},radiusPx:{value:o.radiusPx||100},aspect:{value:1},pixelRatio:{value:r.renderer.getPixelRatio()},intensity:{value:t.intensity||1},textureAspect:{value:m},aspectCorrectionEnabled:{value:!0===t.aspectCorrection&&!(n&&n.userData&&n.userData.objectFitHandled)},pixelationEnabled:{value:t.effects.pixelation.enabled||!1},crtEnabled:{value:t.effects.crt.enabled||!1},glitchEnabled:{value:t.effects.glitch.enabled||!1},pixelSize:{value:t.effects.pixelation.pixelSize||8},pixelShape:{value:this.getPixelShapeValue(t.effects.pixelation.pixelShape||"square")},bitDepth:{value:this.getBitDepthValue(t.effects.pixelation.bitDepth||"none")},dithering:{value:this.getDitheringValue(t.effects.pixelation.dithering||"none")},pixelDirection:{value:this.getPixelDirectionValue(t.effects.pixelation.pixelDirection||"square")},interactionEnabled:{value:t.interaction?.enabled||!1},pixelSizeInteractive:{value:this.isEffectInteractive(t,"pixelation","pixelSize")},isText:{value:l?1:0},interactionShape:{value:this.getInteractionShapeValue(d)},interactionTexture:{value:f||null},interactionGradientTexture:{value:u||null},hasCustomInteractionTexture:{value:!!f},interactionTextureAspect:{value:h},effectScale:{value:1},scanlineIntensity:{value:void 0!==t.effects.crt.scanlineIntensity?t.effects.crt.scanlineIntensity:.5},phosphorGlow:{value:void 0!==t.effects.crt.phosphorGlow?t.effects.crt.phosphorGlow:.3},curvature:{value:void 0!==t.effects.crt.curvature?t.effects.crt.curvature:6},chromaticAberration:{value:void 0!==t.effects.crt.chromaticAberration?t.effects.crt.chromaticAberration:.003},scanlineThickness:{value:void 0!==t.effects.crt.scanlineThickness?t.effects.crt.scanlineThickness:.8},scanlineCount:{value:void 0!==t.effects.crt.scanlineCount?t.effects.crt.scanlineCount:0},brightness:{value:void 0!==t.effects.crt.brightness?t.effects.crt.brightness:1},flicker:{value:void 0!==t.effects.crt.flicker&&t.effects.crt.flicker},flickerIntensity:{value:void 0!==t.effects.crt.flickerIntensity?t.effects.crt.flickerIntensity:.5},lineMovement:{value:void 0!==t.effects.crt.lineMovement&&t.effects.crt.lineMovement},lineSpeed:{value:void 0!==t.effects.crt.lineSpeed?t.effects.crt.lineSpeed:1},lineDirection:{value:this.getLineDirectionValue(t.effects.crt.lineDirection||"up")},interactionEnabled:{value:t.interaction?.enabled||!1},chromaticAberrationInteractive:{value:this.isEffectInteractive(t,"crt","chromaticAberration")},scanlinesInteractive:{value:this.isEffectInteractive(t,"crt","scanlines")},phosphorGlowInteractive:{value:this.isEffectInteractive(t,"crt","phosphorGlow")},curvatureInteractive:{value:this.isEffectInteractive(t,"crt","curvature")},pixelationEnabled:{value:t.effects.pixelation.enabled||!1},pixelSize:{value:t.effects.pixelation.pixelSize||8},rgbShift:{value:void 0!==t.effects.glitch.rgbShift?t.effects.glitch.rgbShift:.005},digitalNoise:{value:void 0!==t.effects.glitch.digitalNoise?t.effects.glitch.digitalNoise:.1},lineDisplacement:{value:void 0!==t.effects.glitch.lineDisplacement?t.effects.glitch.lineDisplacement:.01},bitCrushDepth:{value:void 0!==t.effects.glitch.bitCrushDepth?t.effects.glitch.bitCrushDepth:0},signalDropoutFreq:{value:void 0!==t.effects.glitch.signalDropoutFreq?t.effects.glitch.signalDropoutFreq:0},signalDropoutSize:{value:void 0!==t.effects.glitch.signalDropoutSize?t.effects.glitch.signalDropoutSize:.1},syncErrorFreq:{value:void 0!==t.effects.glitch.syncErrorFreq?t.effects.glitch.syncErrorFreq:0},syncErrorAmount:{value:void 0!==t.effects.glitch.syncErrorAmount?t.effects.glitch.syncErrorAmount:.05},interferenceSpeed:{value:void 0!==t.effects.glitch.interferenceSpeed?t.effects.glitch.interferenceSpeed:1},interferenceIntensity:{value:void 0!==t.effects.glitch.interferenceIntensity?t.effects.glitch.interferenceIntensity:0},frameGhostAmount:{value:void 0!==t.effects.glitch.frameGhostAmount?t.effects.glitch.frameGhostAmount:0},stutterFreq:{value:void 0!==t.effects.glitch.stutterFreq?t.effects.glitch.stutterFreq:0},datamoshStrength:{value:void 0!==t.effects.glitch.datamoshStrength?t.effects.glitch.datamoshStrength:0},interactionEnabled:{value:t.interaction?.enabled||!1},rgbShiftInteractive:{value:this.isEffectInteractive(t,"glitch","rgbShift")},digitalNoiseInteractive:{value:this.isEffectInteractive(t,"glitch","digitalNoise")},lineDisplacementInteractive:{value:this.isEffectInteractive(t,"glitch","lineDisplacement")},bitCrushInteractive:{value:this.isEffectInteractive(t,"glitch","bitCrushing")},signalDropoutInteractive:{value:this.isEffectInteractive(t,"glitch","signalDropout")},syncErrorsInteractive:{value:this.isEffectInteractive(t,"glitch","syncErrors")},interferenceLinesInteractive:{value:this.isEffectInteractive(t,"glitch","interferenceLines")},frameGhostingInteractive:{value:this.isEffectInteractive(t,"glitch","frameGhosting")},stutterFreezeInteractive:{value:this.isEffectInteractive(t,"glitch","stutterFreeze")},datamoshingInteractive:{value:this.isEffectInteractive(t,"glitch","datamoshing")},interactionTextureAspect:{value:h}},transparent:!0});return n&&(n.needsUpdate=!0,n.flipY=!0),p}getPixelShapeValue(e){return{square:0,circle:1,diamond:2,cross:3,plus:4}[e]||0}isEffectInteractive(e,t,n){const i=e.interaction;return!!(i&&i.enabled&&i.effects&&i.effects[t])&&i.effects[t].includes(n)}getInteractionShapeValue(e){return{circle:0,square:1,diamond:2,cross:3,plus:4,custom:5}[e]||0}getCustomShapeSize(e,t,n=.2){let i=null;if(e.effects.pixelation.enabled?i=e.effects.pixelation.interaction:e.effects.crt.enabled?i=e.effects.crt.interaction:e.effects.glitch.enabled&&(i=e.effects.glitch.interaction),!i)return 1;const o=i.customSize;if(null==o||"auto"===o)return 1;if("number"==typeof o&&!isNaN(o))return o;if("string"!=typeof o)return 1;const r=o.trim().match(/^(-?\d*\.?\d+)(px|vw|vh|vmin|vmax|rem|em)?$/i);if(!r)return console.warn(`glitchGL: Could not parse customSize value "${o}". Falling back to 1.0.`),1;const a=parseFloat(r[1]);let s=a;switch((r[2]||"px").toLowerCase()){case"px":default:break;case"vw":s=a/100*window.innerWidth;break;case"vh":s=a/100*window.innerHeight;break;case"vmin":s=a/100*Math.min(window.innerWidth,window.innerHeight);break;case"vmax":s=a/100*Math.max(window.innerWidth,window.innerHeight);break;case"rem":s=a*(parseFloat(getComputedStyle(document.documentElement).fontSize)||16);break;case"em":{let e=16;if(t){const n=getComputedStyle(t);e=parseFloat(n.fontSize)||e}else e=parseFloat(getComputedStyle(document.documentElement).fontSize)||e;s=a*e;break}}let l=0,c=0;if(t&&"function"==typeof t.getBoundingClientRect){const e=t.getBoundingClientRect();l=e.width,c=e.height}else l=window.innerWidth,c=window.innerHeight;const f=n*Math.min(l,c);if(0===f)return 1;const u=s/2/f;return isFinite(u)&&u>0?u:1}async loadCustomInteractionTexture(e){if(!e)return null;try{const t=new Image;t.crossOrigin="anonymous";const n=e.toLowerCase().endsWith(".svg");if(n&&navigator.userAgent.includes("Firefox"))try{const n=await fetch(e),i=await n.text(),o=new Blob([i],{type:"image/svg+xml"}),r=URL.createObjectURL(o);await new Promise((e,n)=>{t.onload=()=>{URL.revokeObjectURL(r),e()},t.onerror=()=>{URL.revokeObjectURL(r),n()},t.src=r})}catch(n){await new Promise((n,i)=>{t.onload=n,t.onerror=i,t.src=e})}else await new Promise((n,i)=>{t.onload=n,t.onerror=i,t.src=e});let i,o=null;if(n){const e=document.createElement("canvas"),n=e.getContext("2d",{willReadFrequently:!0}),r=512;e.width=r,e.height=r,n.clearRect(0,0,r,r),navigator.userAgent.includes("Firefox")&&(await new Promise(e=>setTimeout(e,100)),t.width&&t.height||(t.width=r,t.height=r));const a=.7,s=Math.min(r/t.width,r/t.height)*a,l=t.width*s,c=t.height*s,f=(r-l)/2,u=(r-c)/2;n.drawImage(t,f,u,l,c);const d=n.getImageData(0,0,r,r);let h=0,m=0,p=[];for(let e=0;e<d.data.length;e+=4){const t=d.data[e],n=d.data[e+1],i=d.data[e+2],o=d.data[e+3];(t>0||n>0||i>0||o>0)&&(h++,m=Math.max(m,t,n,i)),p.length<10&&(t>0||n>0||i>0||o>0)&&p.push([t,n,i,o])}if(h>0){const e=d.data;for(let t=0;t<e.length;t+=4){const n=e[t],i=e[t+1],o=e[t+2],r=e[t+3];(n>0||i>0||o>0||r>0)&&(e[t+3]=255)}n.putImageData(d,0,0)}else if(console.error("No content found in SVG after drawing!"),navigator.userAgent.includes("Firefox")){n.clearRect(0,0,r,r),n.drawImage(t,0,0,r,r);const e=n.getImageData(0,0,r,r);h=0;for(let t=0;t<e.data.length;t+=4)(e.data[t]>0||e.data[t+1]>0||e.data[t+2]>0||e.data[t+3]>0)&&h++;h>0&&n.putImageData(e,0,0)}i=new THREE.CanvasTexture(e),t.width&&t.height&&(i.image.originalWidth=t.width,i.image.originalHeight=t.height),o=this.generateDistanceFieldTexture(e,r);const v=Math.floor(e.width/2)-25,g=Math.floor(e.height/2)-25,x=n.getImageData(v,g,50,50);let b=!1,y=0;for(let e=3;e<x.data.length;e+=4)255===x.data[e]&&y++,x.data[e]>0&&x.data[e]<255&&(b=!0)}else{i=new THREE.Texture(t);const e=document.createElement("canvas"),n=e.getContext("2d");e.width=512,e.height=512;const r=.7,a=Math.min(512/t.width,512/t.height)*r,s=t.width*a,l=t.height*a,c=(512-s)/2,f=(512-l)/2;n.drawImage(t,c,f,s,l),o=this.generateDistanceFieldTexture(e,512)}return i.minFilter=THREE.LinearFilter,i.magFilter=THREE.LinearFilter,i.format=THREE.RGBAFormat,i.needsUpdate=!0,o&&(o.minFilter=THREE.LinearFilter,o.magFilter=THREE.LinearFilter,o.format=THREE.RGBAFormat,o.needsUpdate=!0),{texture:i,gradientTexture:o}}catch(t){return console.warn(`glitchGL: Failed to load custom interaction texture from ${e}:`,t),null}}getBitDepthValue(e){return{none:0,"1-bit":1,"4-bit":2,"8-bit":3}[e]||0}getDitheringValue(e){return{none:0,"floyd-steinberg":1,bayer:2}[e]||0}getPixelDirectionValue(e){return{square:0,horizontal:1,vertical:2}[e]||0}getLineDirectionValue(e){return{up:0,down:1,left:2,right:3}[e]||0}async elementToTexture(e,t={}){if("video"===e.tagName.toLowerCase()){const t=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);if(await new Promise(n=>{const i=t?2:1;if(e.readyState>=i)n();else{const i=t?"loadeddata":"loadedmetadata";e.addEventListener(i,n,{once:!0})}}),e.paused)try{await e.play()}catch(e){console.warn("glitchGL: Could not auto-play video, user interaction may be required:",e)}const n=new THREE.VideoTexture(e);return n.minFilter=THREE.LinearFilter,n.magFilter=THREE.LinearFilter,n.format=THREE.RGBFormat,t&&(n.generateMipmaps=!1,n.wrapS=THREE.ClampToEdgeWrapping,n.wrapT=THREE.ClampToEdgeWrapping,n.needsUpdate=!0,e.addEventListener("timeupdate",()=>{n.needsUpdate=!0})),n}{const n=await async function(e){const t=document.createElement("canvas"),n=t.getContext("2d",{willReadFrequently:!0});let i,o;const r=e.tagName.toLowerCase(),a=2048;if(t.style.backgroundColor="transparent",["img","svg","canvas","video"].includes(r)){let t=0,n=0;if("img"===r)t=e.naturalWidth||0,n=e.naturalHeight||0;else if("video"===r)t=e.videoWidth||0,n=e.videoHeight||0;else if("canvas"===r)t=e.width||0,n=e.height||0;else if("svg"===r){const i=e.getAttribute("viewBox");if(i){const e=i.split(/[ ,]+/).map(Number);4===e.length&&(t=e[2],n=e[3])}}if(!t||!n){const i=e.getBoundingClientRect();t=i.width,n=i.height}const s=e.getBoundingClientRect(),l=s.width/s.height;if("img"===r||"video"===r)l>=1?(i=a,o=Math.round(a/l)):(o=a,i=Math.round(a*l));else{const e=t/n||1;e>=1?(i=a,o=Math.round(a/e)):(o=a,i=Math.round(a*e))}}else{const t=e.getBoundingClientRect(),n=2;i=Math.min(a,Math.round(t.width*n)),o=Math.min(a,Math.round(t.height*n))}t.width=i,t.height=o,n.clearRect(0,0,t.width,t.height);try{switch(e.tagName.toLowerCase()){case"img":await new Promise((t,r)=>{const a=()=>{const t=window.getComputedStyle(e),r=t.objectFit||"fill",a=t.objectPosition||"center center",s=e.naturalWidth,l=e.naturalHeight;if("fill"===r)n.drawImage(e,0,0,i,o);else{const t=s/l,c=i/o;let f=0,u=0,d=s,h=l,m=0,p=0,v=i,g=o;if("contain"===r)t>c?(g=i/t,p=(o-g)/2):(v=o*t,m=(i-v)/2);else if("cover"===r)if(t>c){const e=o/l;d=i/e,f=(s-d)/2}else{const e=i/s;h=o/e,u=(l-h)/2}else if("none"===r)d=Math.min(s,i),h=Math.min(l,o),f=(s-d)/2,u=(l-h)/2,v=d,g=h,m=(i-v)/2,p=(o-g)/2;else if("scale-down"===r){Math.min(i/s,o/l,1)>=1?(v=s,g=l,m=(i-v)/2,p=(o-g)/2):t>c?(g=i/t,p=(o-g)/2):(v=o*t,m=(i-v)/2)}const x=a.split(" "),b=x[0]||"center",y=x[1]||"center";if("cover"===r){if("left"===b)f=0;else if("right"===b)f=s-d;else if(b.includes("%")){f=(s-d)*(parseFloat(b)/100)}if("top"===y)u=0;else if("bottom"===y)u=l-h;else if(y.includes("%")){u=(l-h)*(parseFloat(y)/100)}}else if("contain"===r||"none"===r||"scale-down"===r){if("left"===b)m=0;else if("right"===b)m=i-v;else if(b.includes("%")){const e=parseFloat(b)/100;m=(i-v)*e}if("top"===y)p=0;else if("bottom"===y)p=o-g;else if(y.includes("%")){const e=parseFloat(y)/100;p=(o-g)*e}}n.drawImage(e,f,u,d,h,m,p,v,g)}};e.complete?(a(),t()):(e.onload=()=>{a(),t()},e.onerror=r)});break;case"svg":const t=(new XMLSerializer).serializeToString(e),r=new Blob([t],{type:"image/svg+xml"}),a=URL.createObjectURL(r),s=new Image;await new Promise((e,t)=>{s.onload=()=>{n.drawImage(s,0,0,i,o),URL.revokeObjectURL(a),e()},s.onerror=t,s.src=a});break;case"canvas":n.drawImage(e,0,0,i,o);break;case"video":e.readyState>=2?n.drawImage(e,0,0,i,o):await new Promise(t=>{e.addEventListener("loadeddata",()=>{n.drawImage(e,0,0,i,o),t()},{once:!0})});break;default:const l=window.getComputedStyle(e),c=e.textContent||e.innerText;if(c&&c.trim()){n.clearRect(0,0,i,o);const t=parseFloat(l.fontSize),r=l.fontFamily||"Arial",a=l.fontWeight||"normal",s=l.fontStyle||"normal",f=l.color||"#ffffff",u=parseFloat(l.lineHeight)||1.2*t,d=e.getBoundingClientRect(),h=Math.min(i/d.width,o/d.height),m=t*h,p=u*h;n.font=`${s} ${a} ${m}px ${r}`,n.fillStyle=f,n.textBaseline="top";const v=l.textAlign||"center",g=c.split(/\s+/),x=[];let b="";const y=.9*i;for(let e of g){const t=b+(b?" ":"")+e;n.measureText(t).width>y&&b?(x.push(b),b=e):b=t}b&&x.push(b);const S=x.length*p;let E=(o-S)/2;x.forEach((e,t)=>{let o=0;"center"===v||"justify"===v?(o=i/2,n.textAlign="center"):"right"===v?(o=i-.05*i,n.textAlign="right"):(o=.05*i,n.textAlign="left");const r=E+t*p;n.fillText(e,o,r)})}}}catch(e){console.error("Error converting element to canvas:",e),n.fillStyle="#333333",n.fillRect(i/4,o/4,i/2,o/2)}return t}(e,t),i=new THREE.CanvasTexture(n);i.minFilter=THREE.LinearFilter,i.magFilter=THREE.LinearFilter,i.format=THREE.RGBAFormat,i.premultiplyAlpha=!1;const o=window.getComputedStyle(e).objectFit||"fill";return i.userData={objectFitHandled:["img","video"].includes(e.tagName.toLowerCase())&&["cover","fill","contain","none","scale-down"].includes(o)},i}}generateDistanceFieldTexture(e,t){const n=document.createElement("canvas"),i=n.getContext("2d");n.width=t,n.height=t;if("filter"in i){const n=document.createElement("canvas"),o=n.getContext("2d");n.width=t,n.height=t;const r=document.createElement("canvas"),a=r.getContext("2d");r.width=t,r.height=t,o.drawImage(e,0,0),a.drawImage(e,0,0),o.filter="blur(8px)",o.drawImage(n,0,0),o.filter="blur(4px)",o.drawImage(n,0,0),a.filter="blur(3px)",a.drawImage(r,0,0),a.filter="blur(1px)",a.drawImage(r,0,0);const s=o.getImageData(0,0,t,t),l=a.getImageData(0,0,t,t),c=t/2,f=t/2,u=i.createImageData(t,t);for(let e=0;e<t;e++)for(let n=0;n<t;n++){const i=4*(e*t+n),o=n-c,r=e-c,a=Math.sqrt(o*o+r*r)/f,d=Math.pow(a,1.5),h=s.data[i+3],m=l.data[i+3]*(1-d)+h*d;u.data[i]=m,u.data[i+1]=m,u.data[i+2]=m,u.data[i+3]=255}i.putImageData(u,0,0)}else{const n=e.getContext("2d").getImageData(0,0,t,t).data,o=3,r=8,a=new Uint8ClampedArray(n.length);for(let e=0;e<n.length;e+=4){const t=n[e+3];a[e]=t,a[e+1]=t,a[e+2]=t,a[e+3]=255}for(let e=0;e<o;e++){const e=new Uint8ClampedArray(a);for(let n=0;n<t;n++)for(let i=0;i<t;i++){let o=0,s=0;for(let a=-r;a<=r;a++){const r=i+a;r>=0&&r<t&&(o+=e[4*(n*t+r)],s++)}const l=4*(n*t+i),c=Math.round(o/s);a[l]=c,a[l+1]=c,a[l+2]=c}for(let e=0;e<t;e++)for(let n=0;n<t;n++){let i=0,o=0;for(let s=-r;s<=r;s++){const r=n+s;r>=0&&r<t&&(i+=a[4*(r*t+e)],o++)}const s=4*(n*t+e),l=Math.round(i/o);a[s]=l,a[s+1]=l,a[s+2]=l}}const s=i.createImageData(t,t);s.data.set(a),i.putImageData(s,0,0)}return new THREE.CanvasTexture(n)}onMouseMove(e){this.handleInteraction(e)}onTouchStart(e){if(e.touches.length>0){const t=e.touches[0];this.mouseVelocity=0,this.lastMousePos.set(t.clientX,t.clientY),this.handleInteraction(t)}}onTouchMove(e){if(e.touches.length>0){const t=e.touches[0];this.handleInteraction(t)}}onTouchEnd(e){for(const[e,t]of this.glitchSystems)t.isMouseOver=!1}handleInteraction(e){const t=new THREE.Vector2(e.clientX,e.clientY),n=t.distanceTo(this.lastMousePos);this.mouseVelocity=.7*this.mouseVelocity+.3*n,this.lastMousePos.copy(t);const i=performance.now();this.lastMoveTime=i;for(const[t,n]of this.glitchSystems){const t=n.element.getBoundingClientRect(),i=e.clientX>=t.left&&e.clientX<=t.right&&e.clientY>=t.top&&e.clientY<=t.bottom;if(n.isMouseOver=i,i){const i=e.clientX-t.left,o=e.clientY-t.top;if(n.currentMouse.set(i,t.height-o),n.needsRender=!0,n.is3D){const e=n.options.tiltFactor||.2,r=i/t.width*2-1,a=-o/t.height*2+1;n.targetRotation.x=a*e,n.targetRotation.y=r*e}}}}animate(){if(!o)return;const e=performance.now()-this.lastMoveTime;let t=!1;for(const[e,n]of this.glitchSystems)if(!1!==n.options.interaction?.velocity){t=!0;break}if(t){if(e>16){const e=.95;this.mouseVelocity*=e,this.mouseVelocity<.01&&(this.mouseVelocity=0)}const t=30,n=Math.min(this.mouseVelocity/t,1);this.targetEffectScale=Math.pow(n,.6);const i=.15,o=this.targetEffectScale-this.currentEffectScale;Math.abs(o)>.001?this.currentEffectScale+=o*i:this.currentEffectScale=this.targetEffectScale}else this.currentEffectScale=1;let n=!1;for(const[e,t]of this.glitchSystems){if(!t.inView)continue;const i=this.renderers.get(e);if(!i)continue;if(!t.glitchMaterial||t.is3D&&!t.elementTexture)continue;const{renderer:o,scene:r,camera:a,postScene:s,postCamera:l,is3D:c}=i,f=this.checkTimeBasedEffects(t);if(!(t.needsRender||f||t.isVideo))continue;if(n=!0,t.time+=.016,t.is3D&&t.model){const e=t.options.tiltSpeed||.05;t.model.rotation.x+=(t.targetRotation.x-t.model.rotation.x)*e,t.model.rotation.y+=(t.targetRotation.y-t.model.rotation.y)*e}const u=[t.glitchMaterial].filter(Boolean);for(const e of u){if(!e)continue;e.uniforms.time.value=t.time,e.uniforms.mousePx.value.copy(t.currentMouse),e.uniforms.effectScale.value=this.currentEffectScale;const n=t.element.getBoundingClientRect();if(e.uniforms.resolution.value.set(n.width,n.height),n.height>0){e.uniforms.aspect.value=n.width/n.height;const t=e.uniforms.u_texture.value;if(t&&t.userData&&t.userData.objectFitHandled){const t=n.width/n.height;e.uniforms.textureAspect.value=t}}const i=e.uniforms.u_texture.value;if(i&&i.isVideoTexture&&t.isVideo){/^((?!chrome|android).)*safari/i.test(navigator.userAgent)&&t.element&&!t.element.paused&&(i.needsUpdate=!0)}}if(c){const e=t.element.getBoundingClientRect();e.height>0&&(a.aspect=e.width/e.height,a.updateProjectionMatrix())}this.updateCanvasPosition(e,t,o),c?(o.setRenderTarget(t.elementTexture),o.render(r,a),o.setRenderTarget(null),o.render(s,l)):o.render(r,a),t.needsRender=!1,t.lastRenderTime=performance.now()}i=n||this.hasAnyTimeBasedEffects()?requestAnimationFrame(()=>this.animate()):null}checkTimeBasedEffects(e){const t=e.options;if(!t||!t.effects)return!1;const n=t.effects.crt,i=t.effects.glitch;return!(!n||!n.enabled||!n.flicker&&!n.lineMovement)||!!(i&&i.enabled&&(i.rgbShift>0||i.digitalNoise>0||i.signalDropoutFreq>0||i.syncErrorFreq>0||i.interferenceIntensity>0||i.frameGhostAmount>0||i.stutterFreq>0||i.datamoshStrength>0))}hasAnyTimeBasedEffects(){for(const[e,t]of this.glitchSystems)if(t.inView&&this.checkTimeBasedEffects(t))return!0;return!1}updateCanvasPosition(e,t,n){const i=n.domElement,o=t.element,r=o.getBoundingClientRect(),a=window.getComputedStyle(o);if(0!==r.width&&0!==r.height&&"0"!==a.opacity&&"none"!==a.display){if(i.style.display="block",n.width===r.width&&n.height===r.height||(n.setSize(r.width,r.height),t.is3D&&t.elementTexture&&t.elementTexture.setSize(r.width,r.height)),!t.is3D&&t.elementTexture&&t.elementTexture.userData&&t.elementTexture.userData.objectFitHandled){const e=r.width/r.height,n=t.lastContainerAspect||e;Math.abs(e-n)>.01&&(t.lastContainerAspect=e,this.elementToTexture(t.element,t.options).then(n=>{t.elementTexture&&t.elementTexture.dispose(),t.elementTexture=n,t.glitchMaterial&&(t.glitchMaterial.uniforms.u_texture.value=n,t.glitchMaterial.uniforms.textureAspect.value=e,t.glitchMaterial.uniforms.aspectCorrectionEnabled.value=!0===t.options.aspectCorrection&&!(n&&n.userData&&n.userData.objectFitHandled)),t.needsRender=!0}))}"static"===a.position?(i.style.position="fixed",i.style.top=`${r.top}px`,i.style.left=`${r.left}px`,i.style.width=`${r.width}px`,i.style.height=`${r.height}px`):(i.style.position=a.position,i.style.top=a.top,i.style.left=a.left,i.style.right=a.right,i.style.bottom=a.bottom,i.style.width=a.width,i.style.height=a.height),i.style.margin="0",i.style.padding="0",i.style.transform="none"!==a.transform?a.transform:"",i.style.transformOrigin=a.transformOrigin,i.style.zIndex=a.zIndex,i.style.borderRadius=a.borderRadius,i.style.boxSizing=a.boxSizing,i.style.objectFit=a.objectFit,i.style.objectPosition=a.objectPosition,i.style.pointerEvents="none"}else i.style.display="none"}removeGlitchSystem(e,t=!1){const n=this.glitchSystems.get(e),i=this.renderers.get(e);if(n){t||setTimeout(()=>{n.element.style.visibility=n.originalVisibility||""},16);const o=document.querySelector(`canvas[data-glitch-target="${e}"]`);o&&o.remove(),n.quad&&(n.quad.geometry&&n.quad.geometry.dispose(),n.quad.material&&n.quad.material.dispose()),n.model&&i.scene&&i.scene.remove(n.model),n.elementTexture&&n.elementTexture.dispose(),n.observer&&n.observer.disconnect(),this.glitchSystems.delete(e),this.targetElements.delete(e)}i&&(i.renderer&&i.renderer.dispose(),i.renderTarget1&&i.renderTarget1.dispose(),i.renderTarget2&&i.renderTarget2.dispose(),this.renderers.delete(e))}startAnimation(){o||(o=!0,this.animate())}triggerRender(e){const t=this.glitchSystems.get(e);t&&(t.needsRender=!0,!i&&o&&this.animate())}triggerRenderAll(){for(const[e,t]of this.glitchSystems)t.needsRender=!0;!i&&o&&this.animate()}stopAnimation(){o&&(o=!1,i&&(cancelAnimationFrame(i),i=null))}dispose(){this.stopAnimation();for(const[e]of this.glitchSystems)this.removeGlitchSystem(e);document.removeEventListener("mousemove",this.onMouseMove),document.removeEventListener("touchstart",this.onTouchStart),document.removeEventListener("touchmove",this.onTouchMove),document.removeEventListener("touchend",this.onTouchEnd);for(const[e,t]of this.renderers)t.renderer&&t.renderer.dispose();this.glitchSystems.clear(),this.targetElements.clear(),this.renderers.clear()}getInteractionOptions(e){return e.interaction||null}getInteractionRadiusPx(e,t){const n=this.getInteractionOptions(e);if(!n||!n.customSize)return 100;const i=n.customSize;if(null==i||"auto"===i)return 100;if("number"==typeof i)return parseFloat(i);if("string"!=typeof i)return 100;const o=i.trim().match(/^(-?\d*\.?\d+)(px|vw|vh|vmin|vmax|rem|em)?$/i);if(!o)return console.warn(`glitchGL: Could not parse customSize value "${i}". Falling back to 100px.`),100;const r=parseFloat(o[1]);let a=r;switch((o[2]||"px").toLowerCase()){case"px":default:break;case"vw":a=r/100*window.innerWidth;break;case"vh":a=r/100*window.innerHeight;break;case"vmin":a=r/100*Math.min(window.innerWidth,window.innerHeight);break;case"vmax":a=r/100*Math.max(window.innerWidth,window.innerHeight);break;case"rem":a=r*(parseFloat(getComputedStyle(document.documentElement).fontSize)||16);break;case"em":{let e=16;if(t){const n=getComputedStyle(t);e=parseFloat(n.fontSize)||e}else e=parseFloat(getComputedStyle(document.documentElement).fontSize)||e;a=r*e;break}}return a/2}}class c{constructor(e,n){this.id="glitch-gl-"+ ++t,this.options=e,this.elements=n,this.initialized=!1}async init(){if(!this.initialized){e||(e=new l,e.startAnimation(),function(){if(r)return;let t=window.innerWidth,n=window.innerHeight,i=window.devicePixelRatio;const o=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||"ontouchstart"in window&&window.innerWidth<1024,s=()=>{a&&clearTimeout(a),a=setTimeout(()=>{const r=window.innerWidth,a=window.innerHeight,s=window.devicePixelRatio,l=Math.abs(r-t)>10,c=!o&&Math.abs(a-n)>100;(l||c||s!==i)&&(t=r,n=a,i=s,e&&e.triggerRenderAll())},250)},l=()=>{o&&setTimeout(()=>{s()},500)};window.addEventListener("resize",s),o&&window.addEventListener("orientationchange",l);r={handleResize:s,handleOrientationChange:l,isMobile:o}}());for(let t=0;t<this.elements.length;t++){const n=this.elements[t];try{const i=n.id||`element-${t}`;e.addGlitchSystem(this.id+"-"+i,n,this.options)}catch(e){console.error("glitchGL: Failed to create glitch system for element:",n,e)}}this.initialized=!0,n.set(this.id,this),this.options.on&&this.options.on.init&&this.options.on.init(this)}}cleanup(t=!1){if(this.initialized){for(let n=0;n<this.elements.length;n++){const i=this.elements[n].id||`element-${n}`;e.removeGlitchSystem(this.id+"-"+i,t)}n.delete(this.id),0===n.size&&e&&(e.dispose(),e=null,function(){r&&(window.removeEventListener("resize",r.handleResize),r.isMobile&&window.removeEventListener("orientationchange",r.handleOrientationChange),r=null);a&&(clearTimeout(a),a=null)}()),this.initialized=!1}}async reloadInteractionTexture(){if(e)for(let t=0;t<this.elements.length;t++){const n=this.elements[t].id||`element-${t}`,i=this.id+"-"+n,o=e.glitchSystems.get(i);if(o&&o.glitchMaterial){const t=e.getInteractionOptions(this.options);if(t&&"custom"===t.shape&&t.customUrl){const n=await e.loadCustomInteractionTexture(t.customUrl),i=o.glitchMaterial.uniforms.interactionTexture.value;i&&i.dispose&&i.dispose();const r=o.glitchMaterial.uniforms.interactionGradientTexture.value;r&&r.dispose&&r.dispose(),n?(o.glitchMaterial.uniforms.interactionTexture.value=n.texture||null,o.glitchMaterial.uniforms.interactionGradientTexture.value=n.gradientTexture||null,o.glitchMaterial.uniforms.hasCustomInteractionTexture.value=!(!n.texture||!n.gradientTexture)):(o.glitchMaterial.uniforms.interactionTexture.value=null,o.glitchMaterial.uniforms.interactionGradientTexture.value=null,o.glitchMaterial.uniforms.hasCustomInteractionTexture.value=!1);const a=e.getInteractionShapeValue("custom");if(o.glitchMaterial.uniforms.interactionShape.value=a,n&&n.texture){const e=n.texture.image,t=new THREE.CanvasTexture(e);t.minFilter=THREE.LinearFilter,t.magFilter=THREE.LinearFilter,t.format=THREE.RGBAFormat,t.needsUpdate=!0,o.glitchMaterial.uniforms.interactionTexture.value=t}if(n&&n.texture?.image){n.texture.image.getContext("2d").getImageData(256,256,1,1)}let s=1;n&&n.texture&&n.texture.image&&n.texture.image.width&&n.texture.image.height>0&&(s=n.texture.image.width/n.texture.image.height),o.glitchMaterial.uniforms.interactionTextureAspect.value=s}else if(t&&"custom"!==t.shape){const e=o.glitchMaterial.uniforms.interactionTexture.value;e&&e.dispose&&e.dispose(),o.glitchMaterial.uniforms.interactionTexture.value=null,o.glitchMaterial.uniforms.hasCustomInteractionTexture.value=!1}}}}hasCustomTextureLoaded(){if(!e)return!1;for(let t=0;t<this.elements.length;t++){const n=this.elements[t].id||`element-${t}`,i=this.id+"-"+n,o=e.glitchSystems.get(i);if(o?.glitchMaterial?.uniforms?.hasCustomInteractionTexture?.value)return!0}return!1}didInteractionTextureChange(e,t){const n=e.interaction,i=t.interaction;if(n&&i){if(i.customUrl!==n.customUrl)return!0;if("custom"===i.shape&&"custom"!==n.shape)return!0;if("custom"!==i.shape&&"custom"===n.shape)return!0}return!1}async updateOptions(t){const n=JSON.parse(JSON.stringify(this.options));this.options=this.mergeDeep(this.options,t);const i=this.didInteractionTextureChange(n,this.options),o="custom"===this.options.interaction?.shape&&this.options.interaction?.customUrl&&!this.hasCustomTextureLoaded();(i||o)&&await this.reloadInteractionTexture();for(const[t,n]of e.glitchSystems)if(this.elements.includes(n.element)){const t=e.getInteractionRadiusPx(this.options,n.element);n.radiusPx!==t&&(n.radiusPx=t,n.glitchMaterial&&(n.glitchMaterial.uniforms.radiusPx.value=t))}this.updateShaderUniforms(t)}updateShaderUniforms(t){if(e){for(let n=0;n<this.elements.length;n++){const i=this.elements[n].id||`element-${n}`,o=this.id+"-"+i,r=e.glitchSystems.get(o);if(r&&r.glitchMaterial){const n=[r.glitchMaterial].filter(Boolean);for(const i of n){if(!i)continue;const n=i.uniforms,o=(e,t)=>{n[e]&&(n[e].value=t)};if(void 0!==t.intensity&&o("intensity",t.intensity),t.effects&&(t.effects.pixelation&&void 0!==t.effects.pixelation.enabled&&o("pixelationEnabled",t.effects.pixelation.enabled),t.effects.crt&&void 0!==t.effects.crt.enabled&&o("crtEnabled",t.effects.crt.enabled),t.effects.glitch&&void 0!==t.effects.glitch.enabled&&o("glitchEnabled",t.effects.glitch.enabled)),t.interaction){const n=t.interaction;if(void 0!==n.enabled&&o("interactionEnabled",n.enabled),void 0!==n.shape){o("interactionShape",e.getInteractionShapeValue(n.shape))}void 0!==n.effects&&(void 0!==n.effects.pixelation&&o("pixelSizeInteractive",e.isEffectInteractive(this.options,"pixelation","pixelSize")),void 0!==n.effects.crt&&(o("chromaticAberrationInteractive",e.isEffectInteractive(this.options,"crt","chromaticAberration")),o("scanlinesInteractive",e.isEffectInteractive(this.options,"crt","scanlines")),o("phosphorGlowInteractive",e.isEffectInteractive(this.options,"crt","phosphorGlow")),o("curvatureInteractive",e.isEffectInteractive(this.options,"crt","curvature"))),void 0!==n.effects.glitch&&(o("rgbShiftInteractive",e.isEffectInteractive(this.options,"glitch","rgbShift")),o("digitalNoiseInteractive",e.isEffectInteractive(this.options,"glitch","digitalNoise")),o("lineDisplacementInteractive",e.isEffectInteractive(this.options,"glitch","lineDisplacement")),o("bitCrushInteractive",e.isEffectInteractive(this.options,"glitch","bitCrushing")),o("signalDropoutInteractive",e.isEffectInteractive(this.options,"glitch","signalDropout")),o("syncErrorsInteractive",e.isEffectInteractive(this.options,"glitch","syncErrors")),o("interferenceLinesInteractive",e.isEffectInteractive(this.options,"glitch","interferenceLines")),o("frameGhostingInteractive",e.isEffectInteractive(this.options,"glitch","frameGhosting")),o("stutterFreezeInteractive",e.isEffectInteractive(this.options,"glitch","stutterFreeze")),o("datamoshingInteractive",e.isEffectInteractive(this.options,"glitch","datamoshing"))))}if(t.effects){if(t.effects.pixelation){const n=t.effects.pixelation;void 0!==n.pixelSize&&o("pixelSize",n.pixelSize),void 0!==n.pixelShape&&o("pixelShape",e.getPixelShapeValue(n.pixelShape)),void 0!==n.bitDepth&&o("bitDepth",e.getBitDepthValue(n.bitDepth)),void 0!==n.dithering&&o("dithering",e.getDitheringValue(n.dithering)),void 0!==n.pixelDirection&&o("pixelDirection",e.getPixelDirectionValue(n.pixelDirection))}if(t.effects.crt){const n=t.effects.crt;void 0!==n.scanlineIntensity&&o("scanlineIntensity",n.scanlineIntensity),void 0!==n.phosphorGlow&&o("phosphorGlow",n.phosphorGlow),void 0!==n.curvature&&o("curvature",n.curvature),void 0!==n.chromaticAberration&&o("chromaticAberration",n.chromaticAberration),void 0!==n.scanlineThickness&&o("scanlineThickness",n.scanlineThickness),void 0!==n.scanlineCount&&o("scanlineCount",n.scanlineCount),void 0!==n.brightness&&o("brightness",n.brightness),void 0!==n.flicker&&o("flicker",n.flicker),void 0!==n.flickerIntensity&&o("flickerIntensity",n.flickerIntensity),void 0!==n.lineMovement&&o("lineMovement",n.lineMovement),void 0!==n.lineSpeed&&o("lineSpeed",n.lineSpeed),void 0!==n.lineDirection&&o("lineDirection",e.getLineDirectionValue(n.lineDirection))}if(t.effects.glitch){const e=t.effects.glitch;void 0!==e.rgbShift&&o("rgbShift",e.rgbShift),void 0!==e.digitalNoise&&o("digitalNoise",e.digitalNoise),void 0!==e.lineDisplacement&&o("lineDisplacement",e.lineDisplacement),void 0!==e.bitCrushDepth&&o("bitCrushDepth",e.bitCrushDepth),void 0!==e.signalDropoutFreq&&o("signalDropoutFreq",e.signalDropoutFreq),void 0!==e.signalDropoutSize&&o("signalDropoutSize",e.signalDropoutSize),void 0!==e.syncErrorFreq&&o("syncErrorFreq",e.syncErrorFreq),void 0!==e.syncErrorAmount&&o("syncErrorAmount",e.syncErrorAmount),void 0!==e.interferenceSpeed&&o("interferenceSpeed",e.interferenceSpeed),void 0!==e.interferenceIntensity&&o("interferenceIntensity",e.interferenceIntensity),void 0!==e.frameGhostAmount&&o("frameGhostAmount",e.frameGhostAmount),void 0!==e.stutterFreq&&o("stutterFreq",e.stutterFreq),void 0!==e.datamoshStrength&&o("datamoshStrength",e.datamoshStrength)}}}}}e&&e.triggerRenderAll()}}mergeDeep(e,t){const n=Object.assign({},e);return this.isObject(e)&&this.isObject(t)&&Object.keys(t).forEach(i=>{this.isObject(t[i])?i in e?n[i]=this.mergeDeep(e[i],t[i]):Object.assign(n,{[i]:t[i]}):Object.assign(n,{[i]:t[i]})}),n}isObject(e){return!(!e||"object"!=typeof e||Array.isArray(e))}}const f={"consumer-tv":{scanlineIntensity:.7,scanlineThickness:.8,scanlineCount:240,brightness:1.2,phosphorGlow:.4,curvature:8,chromaticAberration:.004,flicker:!1,flickerIntensity:.5,lineMovement:!1,lineSpeed:1,lineDirection:"up"},"arcade-monitor":{scanlineIntensity:.5,scanlineThickness:.6,scanlineCount:240,brightness:1.4,phosphorGlow:.6,curvature:4,chromaticAberration:.002,flicker:!0,flickerIntensity:.5,lineMovement:!1,lineSpeed:1,lineDirection:"up"},"computer-monitor":{scanlineIntensity:.3,scanlineThickness:.4,scanlineCount:480,brightness:1.1,phosphorGlow:.2,curvature:2,chromaticAberration:.001,flicker:!1,flickerIntensity:.5,lineMovement:!1,lineSpeed:1,lineDirection:"up"},"broadcast-monitor":{scanlineIntensity:.2,scanlineThickness:.3,scanlineCount:720,brightness:4,phosphorGlow:.1,curvature:11.6,chromaticAberration:.0045,flicker:!0,flickerIntensity:.5,lineMovement:!1,lineSpeed:1,lineDirection:"up"}};window.glitchGL=function(e={}){const t={target:".glitchGL",intensity:1,aspectCorrection:!0,modelScale:1,tiltFactor:.2,tiltSpeed:.05,interaction:{enabled:!0,shape:"circle",customSize:"10vw",customUrl:null,velocity:!1,effects:{pixelation:[],crt:[],glitch:[]}},effects:{pixelation:{enabled:!0,pixelSize:8,pixelShape:"square",bitDepth:"none",dithering:"none",pixelDirection:"square"},crt:{enabled:!1,preset:"consumer-tv",...f["consumer-tv"]},glitch:{enabled:!1,rgbShift:0,digitalNoise:.1,lineDisplacement:.01,bitCrushDepth:4,signalDropoutFreq:.05,signalDropoutSize:.1,syncErrorFreq:.02,syncErrorAmount:.05,interferenceSpeed:1,interferenceIntensity:.2,frameGhostAmount:.3,stutterFreq:.1,datamoshStrength:.5}},on:{}};if(e&&e.effects?.crt?.preset&&f[e.effects.crt.preset]){const t=f[e.effects.crt.preset];e.effects.crt={...t,...e.effects.crt}}const n=window.glitchGL.mergeDeep(t,e),i=document.querySelectorAll(n.target);if(0===i.length)return console.error(`glitchGL: No elements found with selector "${n.target}"`),null;const o=new c(n,Array.from(i));return o.init(),{init:()=>o.init(),cleanup:()=>o.cleanup(),updateOptions:e=>o.updateOptions(e),get options(){return o.options},setIntensity:e=>o.updateOptions({intensity:e}),setInteractionRadius:e=>{o.updateOptions({interaction:{customSize:e}})},setPixelSize:e=>o.updateOptions({effects:{pixelation:{pixelSize:e}}}),setPixelShape:e=>o.updateOptions({effects:{pixelation:{pixelShape:e}}}),setBitDepth:e=>o.updateOptions({effects:{pixelation:{bitDepth:e}}}),setDithering:e=>o.updateOptions({effects:{pixelation:{dithering:e}}}),setPixelDirection:e=>o.updateOptions({effects:{pixelation:{pixelDirection:e}}}),setPixelationInteraction:e=>o.updateOptions({interaction:{effects:{pixelation:e}}}),setPixelationInteractionShape:(e,t=null,n)=>{const i={shape:e};null!==t&&(i.customUrl=t),void 0!==n&&(i.customSize=n),o.updateOptions({interaction:i})},setScanlineIntensity:e=>o.updateOptions({effects:{crt:{scanlineIntensity:e}}}),setPhosphorGlow:e=>o.updateOptions({effects:{crt:{phosphorGlow:e}}}),setCurvature:e=>o.updateOptions({effects:{crt:{curvature:e}}}),setChromaticAberration:e=>o.updateOptions({effects:{crt:{chromaticAberration:e}}}),setScanlineThickness:e=>o.updateOptions({effects:{crt:{scanlineThickness:e}}}),setScanlineCount:e=>o.updateOptions({effects:{crt:{scanlineCount:e}}}),setBrightness:e=>o.updateOptions({effects:{crt:{brightness:e}}}),setFlicker:e=>o.updateOptions({effects:{crt:{flicker:e}}}),setFlickerIntensity:e=>o.updateOptions({effects:{crt:{flickerIntensity:e}}}),setLineMovement:e=>o.updateOptions({effects:{crt:{lineMovement:e}}}),setLineSpeed:e=>o.updateOptions({effects:{crt:{lineSpeed:e}}}),setLineDirection:e=>o.updateOptions({effects:{crt:{lineDirection:e}}}),setCRTInteraction:e=>o.updateOptions({interaction:{effects:{crt:e}}}),setCRTInteractionShape:(e,t=null,n)=>{const i={shape:e};null!==t&&(i.customUrl=t),void 0!==n&&(i.customSize=n),o.updateOptions({interaction:i})},setCRTPreset:e=>{f[e]?o.updateOptions({effects:{crt:{...f[e],preset:e}}}):console.warn(`glitchGL: Unknown CRT preset "${e}". Available presets: ${Object.keys(f).join(", ")}`)},setRgbShift:e=>o.updateOptions({effects:{glitch:{rgbShift:e}}}),setDigitalNoise:e=>o.updateOptions({effects:{glitch:{digitalNoise:e}}}),setLineDisplacement:e=>o.updateOptions({effects:{glitch:{lineDisplacement:e}}}),setBitCrushDepth:e=>o.updateOptions({effects:{glitch:{bitCrushDepth:e}}}),setSignalDropoutFreq:e=>o.updateOptions({effects:{glitch:{signalDropoutFreq:e}}}),setSignalDropoutSize:e=>o.updateOptions({effects:{glitch:{signalDropoutSize:e}}}),setSyncErrorFreq:e=>o.updateOptions({effects:{glitch:{syncErrorFreq:e}}}),setSyncErrorAmount:e=>o.updateOptions({effects:{glitch:{syncErrorAmount:e}}}),setInterferenceSpeed:e=>o.updateOptions({effects:{glitch:{interferenceSpeed:e}}}),setInterferenceIntensity:e=>o.updateOptions({effects:{glitch:{interferenceIntensity:e}}}),setFrameGhostAmount:e=>o.updateOptions({effects:{glitch:{frameGhostAmount:e}}}),setStutterFreq:e=>o.updateOptions({effects:{glitch:{stutterFreq:e}}}),setDatamoshStrength:e=>o.updateOptions({effects:{glitch:{datamoshStrength:e}}}),setGlitchInteraction:e=>o.updateOptions({interaction:{effects:{glitch:e}}}),setGlitchInteractionShape:(e,t=null,n)=>{const i={shape:e};null!==t&&(i.customUrl=t),void 0!==n&&(i.customSize=n),o.updateOptions({interaction:i})},enableGlitchInteraction:()=>o.updateOptions({interaction:{enabled:!0}}),disableGlitchInteraction:()=>o.updateOptions({interaction:{enabled:!1}}),animate:(e,t,n,i,r="linear")=>new Promise(a=>{const s=performance.now(),l=t,c=n-l,f={linear:e=>e,easeIn:e=>e*e,easeOut:e=>e*(2-e),easeInOut:e=>e<.5?2*e*e:(4-2*e)*e-1},u=f[r]||f.linear,d=()=>{const t=performance.now()-s,n=Math.min(t/i,1),r=u(n),f=l+c*r;"intensity"===e?o.updateOptions({intensity:f}):"interactionRadius"===e?o.updateOptions({interaction:{customSize:f}}):"pixelSize"===e?o.updateOptions({effects:{pixelation:{pixelSize:f}}}):"scanlineIntensity"===e?o.updateOptions({effects:{crt:{scanlineIntensity:f}}}):"rgbShift"===e?o.updateOptions({effects:{glitch:{rgbShift:f}}}):"bitCrushDepth"===e?o.updateOptions({effects:{glitch:{bitCrushDepth:f}}}):"datamoshStrength"===e?o.updateOptions({effects:{glitch:{datamoshStrength:f}}}):"interferenceIntensity"===e&&o.updateOptions({effects:{glitch:{interferenceIntensity:f}}}),n<1?requestAnimationFrame(d):a()};d()}),enablePixelation:()=>o.updateOptions({effects:{pixelation:{enabled:!0}}}),enableCRT:()=>o.updateOptions({effects:{crt:{enabled:!0}}}),enableGlitch:()=>o.updateOptions({effects:{glitch:{enabled:!0}}}),disablePixelation:()=>o.updateOptions({effects:{pixelation:{enabled:!1}}}),disableCRT:()=>o.updateOptions({effects:{crt:{enabled:!1}}}),disableGlitch:()=>o.updateOptions({effects:{glitch:{enabled:!1}}}),disableAll:()=>o.updateOptions({effects:{pixelation:{enabled:!1},crt:{enabled:!1},glitch:{enabled:!1}}}),enableOnlyPixelation:()=>o.updateOptions({effects:{pixelation:{enabled:!0},crt:{enabled:!1},glitch:{enabled:!1}}}),enableOnlyCRT:()=>o.updateOptions({effects:{pixelation:{enabled:!1},crt:{enabled:!0},glitch:{enabled:!1}}}),enableOnlyGlitch:()=>o.updateOptions({effects:{pixelation:{enabled:!1},crt:{enabled:!1},glitch:{enabled:!0}}}),enableAllEffects:()=>o.updateOptions({effects:{pixelation:{enabled:!0},crt:{enabled:!0},glitch:{enabled:!0}}}),setEffectsEnabled:(e,t,n)=>o.updateOptions({effects:{pixelation:{enabled:e},crt:{enabled:t},glitch:{enabled:n}}}),setInteractionShape:(e,t=null,n)=>{const i={shape:e};null!==t&&(i.customUrl=t),void 0!==n&&(i.customSize=n),o.updateOptions({interaction:i})},setCircleInteraction:()=>o.updateOptions({interaction:{shape:"circle"}}),setSquareInteraction:()=>o.updateOptions({interaction:{shape:"square"}}),setDiamondInteraction:()=>o.updateOptions({interaction:{shape:"diamond"}}),setCrossInteraction:()=>o.updateOptions({interaction:{shape:"cross"}}),setPlusInteraction:()=>o.updateOptions({interaction:{shape:"plus"}}),setCustomInteraction:(e,t)=>{const n={shape:"custom",customUrl:e};void 0!==t&&(n.customSize=t),o.updateOptions({interaction:n})},setCustomShapeSize:e=>{o.updateOptions({interaction:{customSize:e}})}}},window.glitchGL.presets={crt:f},window.glitchGL.mergeDeep=function(e,t){const n=Object.assign({},e);return window.glitchGL.isObject(e)&&window.glitchGL.isObject(t)&&Object.keys(t).forEach(i=>{window.glitchGL.isObject(t[i])?i in e?n[i]=window.glitchGL.mergeDeep(e[i],t[i]):Object.assign(n,{[i]:t[i]}):Object.assign(n,{[i]:t[i]})}),n},window.glitchGL.isObject=function(e){return!(!e||"object"!=typeof e||Array.isArray(e))}}();